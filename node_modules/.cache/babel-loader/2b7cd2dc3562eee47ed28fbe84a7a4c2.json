{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nconst whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from './cpu_util';\nexport class MathBackendCPU extends KernelBackend {\n  constructor() {\n    super();\n    this.blockSize = 48;\n    this.firstUse = true;\n    this.data = new DataStorage(this, engine());\n  }\n\n  nextDataId() {\n    return MathBackendCPU.nextDataId++;\n  }\n\n  write(values, shape, dtype) {\n    if (this.firstUse) {\n      this.firstUse = false;\n\n      if (env().get('IS_NODE')) {\n        backend_util.warn('\\n============================\\n' + 'Hi, looks like you are running TensorFlow.js in ' + 'Node.js. To speed things up dramatically, install our node ' + 'backend, visit https://github.com/tensorflow/tfjs-node for more details. ' + '\\n============================');\n      }\n    }\n\n    const dataId = {\n      id: this.nextDataId()\n    };\n    this.data.set(dataId, {\n      values,\n      dtype,\n      refCount: 1\n    });\n    return dataId;\n  }\n  /**\n   * Create a data bucket in cpu backend.\n   * @param shape Shape of the `TensorInfo`.\n   * @param dtype DType of the `TensorInfo`.\n   * @param values The value of the `TensorInfo` stored as a flattened array.\n   */\n\n\n  makeTensorInfo(shape, dtype, values) {\n    let outId;\n\n    if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n      const encodedValues = values.map(d => util.encodeString(d));\n      outId = this.write(encodedValues, shape, dtype);\n    } else {\n      outId = this.write(values, shape, dtype);\n    }\n\n    return {\n      dataId: outId,\n      shape,\n      dtype\n    };\n  }\n  /** Return refCount of a `TensorData`. */\n\n\n  refCount(dataId) {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      return tensorData.refCount;\n    }\n\n    return 0;\n  }\n  /** Increase refCount of a `TensorData`. */\n\n\n  incRef(dataId) {\n    const tensorData = this.data.get(dataId);\n    tensorData.refCount++;\n  }\n  /** Decrease refCount of a `TensorData`. */\n\n\n  decRef(dataId) {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n\n  move(dataId, values, shape, dtype, refCount) {\n    this.data.set(dataId, {\n      values,\n      dtype,\n      refCount\n    });\n  }\n\n  numDataIds() {\n    return this.data.numDataIds();\n  }\n\n  async read(dataId) {\n    return this.readSync(dataId);\n  }\n\n  readSync(dataId) {\n    const {\n      dtype,\n      complexTensorInfos\n    } = this.data.get(dataId);\n\n    if (dtype === 'complex64') {\n      const realValues = this.readSync(complexTensorInfos.real.dataId);\n      const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n      return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    }\n\n    return this.data.get(dataId).values;\n  }\n\n  bufferSync(t) {\n    const data = this.readSync(t.dataId);\n\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = data.map(d => util.decodeString(d));\n        return buffer(t.shape, t.dtype, strings);\n      } catch (_a) {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n\n    return buffer(t.shape, t.dtype, data);\n  }\n\n  makeOutput(values, shape, dtype) {\n    return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);\n  }\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released or memory is not managed in this backend, false if memory is\n   * not cleared.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n\n\n  disposeData(dataId) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.data.has(dataId)) {\n      this.data.get(dataId).refCount--;\n\n      if (!force && this.data.get(dataId).refCount > 0) {\n        return false;\n      }\n\n      const {\n        complexTensorInfos\n      } = this.data.get(dataId);\n\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, true);\n        this.disposeData(complexTensorInfos.imag.dataId, true);\n      }\n\n      this.data.delete(dataId);\n    }\n\n    return true;\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo) {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  async time(f) {\n    const start = util.now();\n    f();\n    const kernelMs = util.now() - start;\n    return {\n      kernelMs\n    };\n  }\n\n  memory() {\n    return {\n      // Unreliable due to automatic gc. The numbers above are cumulative.\n      unreliable: true,\n      reasons: ['The reported memory is an upper bound. Due to automatic garbage ' + 'collection, the true allocated memory may be less.']\n    };\n  }\n\n  where(condition) {\n    assertNotComplex([condition], 'where');\n    const condVals = this.readSync(condition.dataId);\n    return whereImpl(condition.shape, condVals);\n  }\n\n  dispose() {}\n\n  floatPrecision() {\n    return 32;\n  }\n  /** Returns the smallest representable number.  */\n\n\n  epsilon() {\n    return super.epsilon();\n  }\n\n}\nMathBackendCPU.nextDataId = 0;","map":{"version":3,"sources":["../../../../../tfjs-backend-cpu/src/backend_cpu.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BackendTimingInfo, buffer, DataStorage, DataType, engine, env, kernel_impls, KernelBackend, Rank, ShapeMap, Tensor, Tensor2D, TensorBuffer, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nconst whereImpl = kernel_impls.whereImpl;\nimport {assertNotComplex} from './cpu_util';\n\ninterface DataId {}\n\nexport interface TensorData<D extends DataType> {\n  values?: backend_util.BackendValues;\n  dtype: D;\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensors, with a parent joining the two with the\n  // complexTensorInfos field.\n  complexTensorInfos?: {real: TensorInfo, imag: TensorInfo};\n  // refCount keeps track of how many tensors reference it. Used for memory\n  // management.\n  refCount: number;\n}\n\nexport class MathBackendCPU extends KernelBackend {\n  public blockSize = 48;\n\n  data: DataStorage<TensorData<DataType>>;\n  private firstUse = true;\n  private static nextDataId = 0;\n  private nextDataId(): number {\n    return MathBackendCPU.nextDataId++;\n  }\n\n  constructor() {\n    super();\n    this.data = new DataStorage(this, engine());\n  }\n\n  write(values: backend_util.BackendValues, shape: number[], dtype: DataType):\n      DataId {\n    if (this.firstUse) {\n      this.firstUse = false;\n      if (env().get('IS_NODE')) {\n        backend_util.warn(\n            '\\n============================\\n' +\n            'Hi, looks like you are running TensorFlow.js in ' +\n            'Node.js. To speed things up dramatically, install our node ' +\n            'backend, visit https://github.com/tensorflow/tfjs-node for more details. ' +\n            '\\n============================');\n      }\n    }\n    const dataId = {id: this.nextDataId()};\n\n    this.data.set(dataId, {values, dtype, refCount: 1});\n\n    return dataId;\n  }\n\n  /**\n   * Create a data bucket in cpu backend.\n   * @param shape Shape of the `TensorInfo`.\n   * @param dtype DType of the `TensorInfo`.\n   * @param values The value of the `TensorInfo` stored as a flattened array.\n   */\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: backend_util.BackendValues|string[]): TensorInfo {\n    let outId;\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      const encodedValues =\n          (values as {} as string[]).map(d => util.encodeString(d));\n\n      outId = this.write(encodedValues, shape, dtype);\n    } else {\n      outId = this.write(values as TypedArray, shape, dtype);\n    }\n\n    return {dataId: outId, shape, dtype};\n  }\n\n  /** Return refCount of a `TensorData`. */\n  refCount(dataId: DataId): number {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TensorData`. */\n  incRef(dataId: DataId): void {\n    const tensorData = this.data.get(dataId);\n    tensorData.refCount++;\n  }\n\n  /** Decrease refCount of a `TensorData`. */\n  decRef(dataId: DataId): void {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n\n  move(\n      dataId: DataId, values: backend_util.BackendValues, shape: number[],\n      dtype: DataType, refCount: number): void {\n    this.data.set(dataId, {values, dtype, refCount});\n  }\n\n  numDataIds(): number {\n    return this.data.numDataIds();\n  }\n\n  async read(dataId: DataId): Promise<backend_util.BackendValues> {\n    return this.readSync(dataId);\n  }\n  readSync(dataId: DataId): backend_util.BackendValues {\n    const {dtype, complexTensorInfos} = this.data.get(dataId);\n\n    if (dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    }\n\n    return this.data.get(dataId).values;\n  }\n\n  bufferSync<R extends Rank, D extends DataType>(t: TensorInfo):\n      TensorBuffer<R, D> {\n    const data = this.readSync(t.dataId);\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = (data as Uint8Array[]).map(d => util.decodeString(d));\n        return buffer(t.shape as ShapeMap[R], t.dtype, strings) as\n            TensorBuffer<R, D>;\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, data as TypedArray) as\n        TensorBuffer<R, D>;\n  }\n\n  makeOutput<T extends Tensor>(\n      values: backend_util.BackendValues, shape: number[], dtype: DataType): T {\n    return engine().makeTensorFromTensorInfo(\n               this.makeTensorInfo(shape, dtype, values), this) as T;\n  }\n\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released or memory is not managed in this backend, false if memory is\n   * not cleared.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  disposeData(dataId: DataId, force = false): boolean {\n    if (this.data.has(dataId)) {\n      this.data.get(dataId).refCount--;\n      if (!force && this.data.get(dataId).refCount > 0) {\n        return false;\n      }\n\n      const {complexTensorInfos} = this.data.get(dataId);\n\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, true);\n        this.disposeData(complexTensorInfos.imag.dataId, true);\n      }\n\n      this.data.delete(dataId);\n    }\n    return true;\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo: TensorInfo): void {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  async time(f: () => void): Promise<BackendTimingInfo> {\n    const start = util.now();\n    f();\n    const kernelMs = util.now() - start;\n    return {kernelMs};\n  }\n\n  memory() {\n    return {\n      // Unreliable due to automatic gc. The numbers above are cumulative.\n      unreliable: true,\n      reasons:\n          ['The reported memory is an upper bound. Due to automatic garbage ' +\n           'collection, the true allocated memory may be less.']\n    };\n  }\n\n  where(condition: Tensor): Tensor2D {\n    assertNotComplex([condition], 'where');\n\n    const condVals = this.readSync(condition.dataId) as TypedArray;\n    return whereImpl(condition.shape, condVals);\n  }\n\n  dispose() {}\n\n  floatPrecision(): 16|32 {\n    return 32;\n  }\n\n  /** Returns the smallest representable number.  */\n  epsilon(): number {\n    return super.epsilon();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}