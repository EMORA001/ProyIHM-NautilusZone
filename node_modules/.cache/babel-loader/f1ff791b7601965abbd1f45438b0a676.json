{"ast":null,"code":"/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  constructor() {\n    let weightMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let tensorArrayMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tensorListMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let functionMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n\n\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\n   * Returns the current context in string format.\n   */\n\n\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n\n\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n\n  generateCurrentContextIds() {\n    const names = [];\n\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : `${context.frameName}-${context.iterationId}`).join('/') : '';\n  }\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n\n\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n\n\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n\n\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../../../tfjs-converter/src/executor/execution_context.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap, TensorArrayMap, TensorListMap} from '../data/types';\n\nimport {TensorArray} from './tensor_array';\nimport {TensorList} from './tensor_list';\nimport {FunctionExecutor} from './types';\n\nexport interface ExecutionContextInfo {\n  id: number;           // the unique id of the context info\n  frameName: string;    // The frame name of the loop, this comes from\n                        // the TensorFlow NodeDef.\n  iterationId: number;  // The iteration id of the loop\n}\n\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  private rootContext = {id: 0, frameName: '', iterationId: 0};\n  private contexts: ExecutionContextInfo[] = [this.rootContext];\n  private lastId = 0;\n  private _currentContextIds: string[];\n\n  constructor(\n      readonly weightMap: NamedTensorsMap = {},\n      readonly tensorArrayMap: TensorArrayMap = {},\n      readonly tensorListMap: TensorListMap = {},\n      readonly functionMap: {[key: string]: FunctionExecutor} = {}) {\n    this.generateCurrentContextIds();\n  }\n\n  private newFrame(id: number, frameName: string) {\n    return {id, frameName, iterationId: 0};\n  }\n\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts: ExecutionContextInfo[]) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext(): ExecutionContextInfo[] {\n    return this.contexts;\n  }\n\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId(): string {\n    return this._currentContextIds[0];\n  }\n\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds(): string[] {\n    return this._currentContextIds;\n  }\n\n  private generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  private contextIdforContexts(contexts: ExecutionContextInfo[]) {\n    return contexts ?\n        contexts\n            .map(\n                context => (context.id === 0 && context.iterationId === 0) ?\n                    '' :\n                    `${context.frameName}-${context.iterationId}`)\n            .join('/') :\n        '';\n  }\n\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId: string) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context =\n          Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(\n          0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name: string): Tensor[] {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray: TensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id: number): TensorArray {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList: TensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id: number): TensorList {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds: Set<number>) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}