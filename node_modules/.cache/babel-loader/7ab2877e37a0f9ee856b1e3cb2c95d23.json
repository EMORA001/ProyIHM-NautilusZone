{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\n\nexport function createSimpleBinaryKernelImpl(op) {\n  return (aShape, bShape, aVals, bVals, dtype) => {\n    const newShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const resultRank = newShape.length;\n    const resultStrides = util.computeStrides(newShape);\n    const resultSize = util.sizeFromShape(newShape);\n    const result = util.getTypedArrayFromDType(dtype, resultSize);\n    const aRank = aShape.length;\n    const bRank = bShape.length;\n    const aStrides = util.computeStrides(aShape);\n    const bStrides = util.computeStrides(bShape);\n    const aBroadcastDims = backend_util.getBroadcastDims(aShape, newShape);\n    const bBroadcastDims = backend_util.getBroadcastDims(bShape, newShape);\n\n    if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n      for (let i = 0; i < result.length; ++i) {\n        result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n      }\n    } else {\n      for (let i = 0; i < result.length; ++i) {\n        const loc = util.indexToLoc(i, resultRank, resultStrides);\n        const aLoc = loc.slice(-aRank);\n        aBroadcastDims.forEach(d => aLoc[d] = 0);\n        const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n        const bLoc = loc.slice(-bRank);\n        bBroadcastDims.forEach(d => bLoc[d] = 0);\n        const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n        result[i] = op(aVals[aIndex], bVals[bIndex]);\n      }\n    }\n\n    return [result, newShape];\n  };\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/utils/binary_impl.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAR,EAAyE,IAAzE,QAAoF,uBAApF;AAIA;;AAEG;;AACH,OAAM,SAAU,4BAAV,CAAuC,EAAvC,EAAgE;EAEpE,OAAO,CAAC,MAAD,EAAmB,MAAnB,EAAqC,KAArC,EACC,KADD,EACoB,KADpB,KAC+D;IACpE,MAAM,QAAQ,GAAG,YAAY,CAAC,0BAAb,CAAwC,MAAxC,EAAgD,MAAhD,CAAjB;IAEA,MAAM,UAAU,GAAG,QAAQ,CAAC,MAA5B;IACA,MAAM,aAAa,GAAG,IAAI,CAAC,cAAL,CAAoB,QAApB,CAAtB;IACA,MAAM,UAAU,GAAG,IAAI,CAAC,aAAL,CAAmB,QAAnB,CAAnB;IAEA,MAAM,MAAM,GACR,IAAI,CAAC,sBAAL,CAA4B,KAA5B,EAAsD,UAAtD,CADJ;IAGA,MAAM,KAAK,GAAG,MAAM,CAAC,MAArB;IACA,MAAM,KAAK,GAAG,MAAM,CAAC,MAArB;IAEA,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAL,CAAoB,MAApB,CAAjB;IACA,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAL,CAAoB,MAApB,CAAjB;IAEA,MAAM,cAAc,GAAG,YAAY,CAAC,gBAAb,CAA8B,MAA9B,EAAsC,QAAtC,CAAvB;IACA,MAAM,cAAc,GAAG,YAAY,CAAC,gBAAb,CAA8B,MAA9B,EAAsC,QAAtC,CAAvB;;IAEA,IAAI,cAAc,CAAC,MAAf,GAAwB,cAAc,CAAC,MAAvC,KAAkD,CAAtD,EAAyD;MACvD,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,EAAE,CAArC,EAAwC;QACtC,MAAM,CAAC,CAAD,CAAN,GAAY,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,MAAX,CAAN,EAA0B,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,MAAX,CAA/B,CAAd;MACD;IACF,CAJD,MAIO;MACL,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,EAAE,CAArC,EAAwC;QACtC,MAAM,GAAG,GAAG,IAAI,CAAC,UAAL,CAAgB,CAAhB,EAAmB,UAAnB,EAA+B,aAA/B,CAAZ;QAEA,MAAM,IAAI,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAC,KAAX,CAAb;QACA,cAAc,CAAC,OAAf,CAAuB,CAAC,IAAI,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAtC;QACA,MAAM,MAAM,GAAG,IAAI,CAAC,UAAL,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,QAA7B,CAAf;QAEA,MAAM,IAAI,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAC,KAAX,CAAb;QACA,cAAc,CAAC,OAAf,CAAuB,CAAC,IAAI,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAtC;QACA,MAAM,MAAM,GAAG,IAAI,CAAC,UAAL,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,QAA7B,CAAf;QAEA,MAAM,CAAC,CAAD,CAAN,GAAY,EAAE,CAAC,KAAK,CAAC,MAAD,CAAN,EAAgB,KAAK,CAAC,MAAD,CAArB,CAAd;MACD;IACF;;IAED,OAAO,CAAC,MAAD,EAAS,QAAT,CAAP;EACD,CAzCD;AA0CD","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, DataValues, NumericDataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {SimpleBinaryKernelImpl, SimpleBinaryOperation} from './binary_types';\n\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nexport function createSimpleBinaryKernelImpl(op: SimpleBinaryOperation):\n    SimpleBinaryKernelImpl {\n  return (aShape: number[], bShape: number[], aVals: DataValues,\n          bVals: DataValues, dtype: DataType): [TypedArray, number[]] => {\n    const newShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n\n    const resultRank = newShape.length;\n    const resultStrides = util.computeStrides(newShape);\n    const resultSize = util.sizeFromShape(newShape);\n\n    const result =\n        util.getTypedArrayFromDType(dtype as NumericDataType, resultSize);\n\n    const aRank = aShape.length;\n    const bRank = bShape.length;\n\n    const aStrides = util.computeStrides(aShape);\n    const bStrides = util.computeStrides(bShape);\n\n    const aBroadcastDims = backend_util.getBroadcastDims(aShape, newShape);\n    const bBroadcastDims = backend_util.getBroadcastDims(bShape, newShape);\n\n    if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n      for (let i = 0; i < result.length; ++i) {\n        result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n      }\n    } else {\n      for (let i = 0; i < result.length; ++i) {\n        const loc = util.indexToLoc(i, resultRank, resultStrides);\n\n        const aLoc = loc.slice(-aRank);\n        aBroadcastDims.forEach(d => aLoc[d] = 0);\n        const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n\n        const bLoc = loc.slice(-bRank);\n        bBroadcastDims.forEach(d => bLoc[d] = 0);\n        const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n\n        result[i] = op(aVals[aIndex], bVals[bIndex]);\n      }\n    }\n\n    return [result, newShape];\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}