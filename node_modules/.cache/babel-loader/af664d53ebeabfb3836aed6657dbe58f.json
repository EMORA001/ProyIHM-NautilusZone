{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\n\nexport function printSummary(model, lineLength, positions) {\n  let printFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;\n  const sequentialLike = isModelSequentialLike(model); // Header names for different log elements.\n\n  const toDisplay = ['Layer (type)', 'Input Shape', 'Output shape', 'Param #'];\n\n  if (sequentialLike) {\n    lineLength = lineLength || 90;\n    positions = positions || [0.32, 0.61, 0.89, 1];\n  } else {\n    lineLength = lineLength || 115;\n    positions = positions || [0.24, 0.48, 0.70, 0.80, 1]; // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(p => Math.floor(lineLength * p));\n  }\n\n  let relevantNodes;\n\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n\n    for (const depth in model.nodesByDepth) {\n      relevantNodes.push(...model.nodesByDepth[depth]);\n    }\n  }\n\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n  const layers = model.layers;\n\n  for (let i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n    }\n\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  } // tslint:disable-next-line:no-any\n\n\n  model.checkTrainableWeightsConsistency();\n  const trainableCount = countTrainableParams(model);\n  const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n  printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n  printFn(`Trainable params: ${trainableCount}`);\n  printFn(`Non-trainable params: ${nonTrainableCount}`);\n  printFn('_'.repeat(lineLength));\n}\n\nfunction countTrainableParams(model) {\n  let trainableCount; // tslint:disable:no-any\n\n  if (model.collectedTrainableWeights != null) {\n    trainableCount = countParamsInWeights(model.collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  } // tslint:enable:no-any\n\n\n  return trainableCount;\n}\n\nfunction isModelSequentialLike(model) {\n  let sequentialLike = true;\n  const nodesByDepth = [];\n  const nodes = [];\n\n  for (const depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n\n  for (const depthNodes of nodesByDepth) {\n    if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n\n    nodes.push(...depthNodes);\n  }\n\n  if (sequentialLike) {\n    // Search for shared layers.\n    for (const layer of model.layers) {\n      let flag = false;\n\n      for (const node of layer.inboundNodes) {\n        if (nodes.indexOf(node) !== -1) {\n          if (flag) {\n            sequentialLike = false;\n            break;\n          } else {\n            flag = true;\n          }\n        }\n      }\n\n      if (!sequentialLike) {\n        break;\n      }\n    }\n  }\n\n  return sequentialLike;\n}\n\nfunction printRow(fields, positions) {\n  let printFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;\n  let line = '';\n\n  for (let i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n\n  printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\n\n\nfunction printLayerSummary(layer, positions, // tslint:disable-next-line:no-any\nprintFn) {\n  let outputShape;\n  let inputShape;\n\n  try {\n    inputShape = layer.inboundNodes.map(x => JSON.stringify(x.inputShapes)).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const name = layer.name;\n  const className = layer.getClassName();\n  const fields = [`${name} (${className})`, inputShape, outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\n\n\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, // tslint:disable-next-line:no-any\nprintFn) {\n  let outputShape;\n  let inputShape;\n\n  try {\n    inputShape = layer.inboundNodes.map(x => JSON.stringify(x.inputShapes)).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const connections = [];\n\n  for (const node of layer.inboundNodes) {\n    if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {\n      continue;\n    }\n\n    for (let i = 0; i < node.inboundLayers.length; ++i) {\n      const inboundLayer = node.inboundLayers[i].name;\n      const inboundLayerIndex = node.nodeIndices[i];\n      const inboundTensorIndex = node.tensorIndices[i];\n      connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n    }\n  }\n\n  const name = layer.name;\n  const className = layer.getClassName();\n  const firstConnection = connections.length === 0 ? '' : connections[0];\n  const fields = [`${name} (${className})`, inputShape, outputShape, layer.countParams().toString(), firstConnection];\n  printRow(fields, positions, printFn);\n\n  for (let i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', '', connections[i]], positions, printFn);\n  }\n}","map":{"version":3,"sources":["../../../../../../tfjs-layers/src/utils/layer_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {Container} from '../engine/container';\nimport {Layer, Node} from '../engine/topology';\nimport {countParamsInWeights} from './variable_utils';\n\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(\n    model: Container, lineLength?: number, positions?: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void =\n        console.log): void {\n  const sequentialLike = isModelSequentialLike(model);\n\n  // Header names for different log elements.\n  const toDisplay: string[] = ['Layer (type)', 'Input Shape', 'Output shape', 'Param #'];\n  if (sequentialLike) {\n    lineLength = lineLength || 90;\n    positions = positions || [0.32, 0.61, 0.89, 1];\n  } else {\n    lineLength = lineLength || 115;\n    positions = positions || [0.24, 0.48, 0.70, 0.80, 1];\n    // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(p => Math.floor(lineLength * p));\n  }\n\n  let relevantNodes: Node[];\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n    for (const depth in model.nodesByDepth) {\n      relevantNodes.push(...model.nodesByDepth[depth]);\n    }\n  }\n\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n\n  const layers = model.layers;\n  for (let i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(\n          layers[i], positions, relevantNodes, printFn);\n    }\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  }\n\n  // tslint:disable-next-line:no-any\n  (model as any).checkTrainableWeightsConsistency();\n\n  const trainableCount = countTrainableParams(model);\n  const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n\n  printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n  printFn(`Trainable params: ${trainableCount}`);\n  printFn(`Non-trainable params: ${nonTrainableCount}`);\n  printFn('_'.repeat(lineLength));\n}\n\nfunction countTrainableParams(model: Container): number {\n  let trainableCount: number;\n  // tslint:disable:no-any\n  if ((model as any).collectedTrainableWeights != null) {\n    trainableCount =\n        countParamsInWeights((model as any).collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  }\n  // tslint:enable:no-any\n  return trainableCount;\n}\n\nfunction isModelSequentialLike(model: Container): boolean {\n  let sequentialLike = true;\n  const nodesByDepth: Node[][] = [];\n  const nodes: Node[] = [];\n  for (const depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n  for (const depthNodes of nodesByDepth) {\n    if (depthNodes.length > 1 ||\n        depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n    nodes.push(...depthNodes);\n  }\n  if (sequentialLike) {\n    // Search for shared layers.\n    for (const layer of model.layers) {\n      let flag = false;\n      for (const node of layer.inboundNodes) {\n        if (nodes.indexOf(node) !== -1) {\n          if (flag) {\n            sequentialLike = false;\n            break;\n          } else {\n            flag = true;\n          }\n        }\n      }\n      if (!sequentialLike) {\n        break;\n      }\n    }\n  }\n  return sequentialLike;\n}\n\nfunction printRow(\n    fields: string[], positions: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void = console.log) {\n  let line = '';\n  for (let i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n  printFn(line);\n}\n\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(\n    layer: Layer, positions: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void) {\n  let outputShape: string;\n  let inputShape: string;\n\n  try {\n    inputShape = (layer.inboundNodes.map(\n      x => JSON.stringify(x.inputShapes)\n    )).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const name = layer.name;\n  const className = layer.getClassName();\n  const fields: string[] =\n      [`${name} (${className})`, inputShape,\n      outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(\n    layer: Layer, positions: number[], relevantNodes: Node[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void) {\n  let outputShape: string;\n  let inputShape: string;\n\n  try {\n    inputShape = (layer.inboundNodes.map(\n      x => JSON.stringify(x.inputShapes)\n    )).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const connections: string[] = [];\n  for (const node of layer.inboundNodes) {\n    if (relevantNodes != null && relevantNodes.length > 0 &&\n        relevantNodes.indexOf(node) === -1) {\n      continue;\n    }\n    for (let i = 0; i < node.inboundLayers.length; ++i) {\n      const inboundLayer = node.inboundLayers[i].name;\n      const inboundLayerIndex = node.nodeIndices[i];\n      const inboundTensorIndex = node.tensorIndices[i];\n      connections.push(\n          `${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n    }\n  }\n  const name = layer.name;\n  const className = layer.getClassName();\n  const firstConnection = connections.length === 0 ? '' : connections[0];\n  const fields: string[] = [\n    `${name} (${className})`, inputShape,\n    outputShape, layer.countParams().toString(),\n    firstConnection\n  ];\n\n  printRow(fields, positions, printFn);\n  for (let i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', '', connections[i]], positions, printFn);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}