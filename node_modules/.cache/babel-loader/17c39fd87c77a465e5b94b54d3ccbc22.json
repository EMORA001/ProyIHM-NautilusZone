{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    y,\n    dy\n  } = inputs;\n  const {\n    depthRadius,\n    bias,\n    alpha,\n    beta\n  } = attrs;\n  assertNotComplex(dy, 'LRNGrad');\n  const dySize = util.sizeFromShape(dy.shape);\n  const channels = dy.shape[3];\n  const dyValues = backend.data.get(dy.dataId).values;\n  const xValues = backend.data.get(x.dataId).values;\n  const yValues = backend.data.get(y.dataId).values;\n  const result = new Float32Array(dySize);\n  const size = dySize;\n\n  for (let offset = 0; offset < size; offset++) {\n    const currentChannel = offset % channels;\n    const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n    const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n    let norm = 0;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n\n    norm = alpha * norm + bias;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n\n      if (offset === k) {\n        dyi += Math.pow(norm, -beta);\n      }\n\n      dyi *= dyValues[offset];\n      result[k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n} // tslint:disable-next-line: variable-name\n\nexport const LRNGradConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad\n};","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/LRNGrad.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAkC,OAAlC,EAAgG,IAAhG,QAA2G,uBAA3G;AAGA,SAAQ,gBAAR,QAA+B,aAA/B;AAEA,OAAM,SAAU,OAAV,CACF,IADE,EAEuE;EAE3E,MAAM;IAAC,MAAD;IAAS,OAAT;IAAkB;EAAlB,IAA2B,IAAjC;EACA,MAAM;IAAC,CAAD;IAAI,CAAJ;IAAO;EAAP,IAAa,MAAnB;EACA,MAAM;IAAC,WAAD;IAAc,IAAd;IAAoB,KAApB;IAA2B;EAA3B,IAAmC,KAAzC;EAEA,gBAAgB,CAAC,EAAD,EAAK,SAAL,CAAhB;EAEA,MAAM,MAAM,GAAG,IAAI,CAAC,aAAL,CAAmB,EAAE,CAAC,KAAtB,CAAf;EAEA,MAAM,QAAQ,GAAG,EAAE,CAAC,KAAH,CAAS,CAAT,CAAjB;EACA,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,EAAE,CAAC,MAApB,EAA4B,MAA7C;EACA,MAAM,OAAO,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,CAAC,CAAC,MAAnB,EAA2B,MAA3C;EACA,MAAM,OAAO,GAAG,OAAO,CAAC,IAAR,CAAa,GAAb,CAAiB,CAAC,CAAC,MAAnB,EAA2B,MAA3C;EACA,MAAM,MAAM,GAAG,IAAI,YAAJ,CAAiB,MAAjB,CAAf;EACA,MAAM,IAAI,GAAG,MAAb;;EAEA,KAAK,IAAI,MAAM,GAAG,CAAlB,EAAqB,MAAM,GAAG,IAA9B,EAAoC,MAAM,EAA1C,EAA8C;IAC5C,MAAM,cAAc,GAAG,MAAM,GAAG,QAAhC;IACA,MAAM,UAAU,GACX,MAAM,GAAG,cAAV,GAA4B,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,cAAc,GAAG,WAA7B,CADhC;IAEA,MAAM,QAAQ,GAAI,MAAM,GAAG,cAAV,GACb,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,cAAc,GAAG,WAAjB,GAA+B,CAAlD,CADJ;IAGA,IAAI,IAAI,GAAG,CAAX;;IACA,KAAK,IAAI,CAAC,GAAG,UAAb,EAAyB,CAAC,GAAG,QAA7B,EAAuC,CAAC,EAAxC,EAA4C;MAC1C,IAAI,IAAI,IAAI,CAAC,GAAL,CAAS,OAAO,CAAC,CAAD,CAAhB,EAAqB,CAArB,CAAR;IACD;;IACD,IAAI,GAAG,KAAK,GAAG,IAAR,GAAe,IAAtB;;IAEA,KAAK,IAAI,CAAC,GAAG,UAAb,EAAyB,CAAC,GAAG,QAA7B,EAAuC,CAAC,EAAxC,EAA4C;MAC1C,IAAI,GAAG,GAAG,CAAC,CAAD,GAAK,KAAL,GAAa,IAAb,GAAoB,OAAO,CAAC,CAAD,CAA3B,GAAiC,OAAO,CAAC,MAAD,CAAxC,GAAmD,IAA7D;;MACA,IAAI,MAAM,KAAK,CAAf,EAAkB;QAChB,GAAG,IAAI,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,CAAC,IAAhB,CAAP;MACD;;MACD,GAAG,IAAI,QAAQ,CAAC,MAAD,CAAf;MACA,MAAM,CAAC,CAAD,CAAN,IAAa,GAAb;IACD;EACF;;EAED,OAAO,OAAO,CAAC,cAAR,CAAuB,EAAE,CAAC,KAA1B,EAAiC,CAAC,CAAC,KAAnC,EAA0C,MAA1C,CAAP;AACD,C,CAED;;AACA,OAAO,MAAM,aAAa,GAAiB;EACzC,UAAU,EAAE,OAD6B;EAEzC,WAAW,EAAE,KAF4B;EAGzC,UAAU,EAAE;AAH6B,CAApC","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LRNGrad, LRNGradAttrs, LRNGradInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function lRNGrad(\n    args:\n        {inputs: LRNGradInputs, backend: MathBackendCPU, attrs: LRNGradAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, y, dy} = inputs;\n  const {depthRadius, bias, alpha, beta} = attrs;\n\n  assertNotComplex(dy, 'LRNGrad');\n\n  const dySize = util.sizeFromShape(dy.shape);\n\n  const channels = dy.shape[3];\n  const dyValues = backend.data.get(dy.dataId).values as TypedArray;\n  const xValues = backend.data.get(x.dataId).values as TypedArray;\n  const yValues = backend.data.get(y.dataId).values as TypedArray;\n  const result = new Float32Array(dySize);\n  const size = dySize;\n\n  for (let offset = 0; offset < size; offset++) {\n    const currentChannel = offset % channels;\n    const depthBegin =\n        (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n    const depthEnd = (offset - currentChannel) +\n        Math.min(channels, currentChannel + depthRadius + 1);\n\n    let norm = 0;\n    for (let k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n    norm = alpha * norm + bias;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n      if (offset === k) {\n        dyi += Math.pow(norm, -beta);\n      }\n      dyi *= dyValues[offset];\n      result[k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\n\n// tslint:disable-next-line: variable-name\nexport const LRNGradConfig: KernelConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}