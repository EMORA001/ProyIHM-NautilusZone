{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\n\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  const usedNodes = new Set();\n  const missingInputs = [];\n  let dynamicNode = null;\n  let syncInputs = null; // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n\n  const seen = new Set();\n  const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\n  let initNodeNames = [];\n\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n  }\n\n  const frontier = [...outputs];\n\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name).filter(name => usedNodes.has(name));\n      }\n    }\n\n    usedNodes.add(node.name); // Weights are dead end since we already have their values.\n\n    if (weightMap[node.name] != null) {\n      continue;\n    } // This node is a dead end since it's one of the user-provided inputs.\n\n\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    } // This node is a dead end since it doesn't have any inputs.\n\n\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n\n  return {\n    inputs,\n    outputs,\n    usedNodes,\n    missingInputs,\n    dynamicNode,\n    syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\n\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n  const {\n    usedNodes,\n    inputs\n  } = executionInfo;\n  const frontier = [];\n  const inputNodes = Object.keys(inputs).map(name => parseNodeName(name)[0]).map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes;\n  inputNodes.forEach(input => {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(weight => {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n\n  if (initNodes != null) {\n    initNodes.forEach(node => {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n\n  const seen = new Set();\n  const orderedNodes = [];\n\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    seen.add(node.name);\n\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n\n    node.children.forEach(child => {\n      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(input => seen.has(input.name))) {\n        frontier.push(child);\n      }\n    });\n  }\n\n  return orderedNodes;\n}\nconst CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While'];\nconst DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'];\nconst HASH_TABLE_OPS = ['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'];\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}","map":{"version":3,"sources":["../../../../../../tfjs-converter/src/executor/model_analysis.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAKH,SAAQ,aAAR,QAA4B,+BAA5B;AAYA;;;;;;;AAOG;;AACH,OAAM,SAAU,oBAAV,CACF,MADE,EACsB,OADtB,EACuC,SADvC,EAEF,SAFE,EAEgB;EACpB,MAAM,SAAS,GAAG,IAAI,GAAJ,EAAlB;EACA,MAAM,aAAa,GAAa,EAAhC;EACA,IAAI,WAAW,GAAS,IAAxB;EACA,IAAI,UAAU,GAAa,IAA3B,CAJoB,CAMpB;EACA;;EACA,MAAM,IAAI,GAAG,IAAI,GAAJ,EAAb;EACA,MAAM,cAAc,GAChB,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,GAApB,CAAwB,IAAI,IAAI,aAAa,CAAC,IAAD,CAAb,CAAoB,CAApB,CAAhC,CADJ;EAGA,IAAI,aAAa,GAAa,EAA9B;;EACA,IAAI,SAAS,IAAI,IAAjB,EAAuB;IACrB,aAAa,GAAG,SAAS,CAAC,GAAV,CAAc,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,IAAN,CAAb,CAAyB,CAAzB,CAAtB,CAAhB;EACD;;EAED,MAAM,QAAQ,GAAG,CAAC,GAAG,OAAJ,CAAjB;;EACA,OAAO,QAAQ,CAAC,MAAT,GAAkB,CAAzB,EAA4B;IAC1B,MAAM,IAAI,GAAG,QAAQ,CAAC,GAAT,EAAb;;IACA,IAAI,aAAa,CAAC,IAAD,CAAb,IAAuB,cAAc,CAAC,IAAD,CAArC,IAA+C,WAAW,CAAC,IAAD,CAA9D,EAAsE;MACpE,IAAI,WAAW,IAAI,IAAnB,EAAyB;QACvB,WAAW,GAAG,IAAd;QACA,UAAU,GAAG,WAAW,CAAC,QAAZ,CAAqB,GAArB,CAAyB,KAAK,IAAI,KAAK,CAAC,IAAxC,EACK,MADL,CACY,IAAI,IAAI,SAAS,CAAC,GAAV,CAAc,IAAd,CADpB,CAAb;MAED;IACF;;IACD,SAAS,CAAC,GAAV,CAAc,IAAI,CAAC,IAAnB,EAT0B,CAW1B;;IACA,IAAI,SAAS,CAAC,IAAI,CAAC,IAAN,CAAT,IAAwB,IAA5B,EAAkC;MAChC;IACD,CAdyB,CAe1B;;;IACA,IAAI,cAAc,CAAC,OAAf,CAAuB,IAAI,CAAC,IAA5B,MAAsC,CAAC,CAA3C,EAA8C;MAC5C;IACD,CAlByB,CAmB1B;;;IACA,IAAI,aAAa,CAAC,OAAd,CAAsB,IAAI,CAAC,IAA3B,MAAqC,CAAC,CAA1C,EAA6C;MAC3C;IACD;;IACD,IAAI,IAAI,CAAC,MAAL,CAAY,MAAZ,KAAuB,CAA3B,EAA8B;MAC5B,aAAa,CAAC,IAAd,CAAmB,IAAI,CAAC,IAAxB;MACA;IACD;;IACD,IAAI,CAAC,MAAL,CAAY,OAAZ,CAAoB,KAAK,IAAG;MAC1B;MACA,IAAI,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,IAAf,CAAJ,EAA0B;QACxB;MACD;;MACD,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,IAAf;MACA,QAAQ,CAAC,IAAT,CAAc,KAAd;IACD,CAPD;EAQD;;EACD,OAAO;IAAC,MAAD;IAAS,OAAT;IAAkB,SAAlB;IAA6B,aAA7B;IAA4C,WAA5C;IAAyD;EAAzD,CAAP;AACD;AAED;;;AAGG;;AACH,OAAM,SAAU,0BAAV,CACF,KADE,EACY,SADZ,EAEF,aAFE,EAE0B;EAC9B,MAAM;IAAC,SAAD;IAAY;EAAZ,IAAsB,aAA5B;EACA,MAAM,QAAQ,GAAW,EAAzB;EACA,MAAM,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,MAAZ,EACK,GADL,CACS,IAAI,IAAI,aAAa,CAAC,IAAD,CAAb,CAAoB,CAApB,CADjB,EAEK,GAFL,CAES,IAAI,IAAI,KAAK,CAAC,KAAN,CAAY,IAAZ,CAFjB,CAAnB;EAGA,MAAM,SAAS,GAAG,KAAK,CAAC,SAAxB;EAEA,UAAU,CAAC,OAAX,CAAmB,KAAK,IAAG;IACzB,IAAI,SAAS,CAAC,GAAV,CAAc,KAAK,CAAC,IAApB,CAAJ,EAA+B;MAC7B,QAAQ,CAAC,IAAT,CAAc,KAAd;IACD;EACF,CAJD;EAKA,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,MAAM,IAAG;IAC7B,IAAI,SAAS,CAAC,GAAV,CAAc,MAAM,CAAC,IAArB,CAAJ,EAAgC;MAC9B,QAAQ,CAAC,IAAT,CAAc,MAAd;IACD;EACF,CAJD;;EAKA,IAAI,SAAS,IAAI,IAAjB,EAAuB;IACrB,SAAS,CAAC,OAAV,CAAkB,IAAI,IAAG;MACvB,IAAI,SAAS,CAAC,GAAV,CAAc,IAAI,CAAC,IAAnB,CAAJ,EAA8B;QAC5B,QAAQ,CAAC,IAAT,CAAc,IAAd;MACD;IACF,CAJD;EAKD;;EACD,MAAM,IAAI,GAAG,IAAI,GAAJ,EAAb;EACA,MAAM,YAAY,GAAW,EAA7B;;EACA,OAAO,QAAQ,CAAC,MAAT,GAAkB,CAAzB,EAA4B;IAC1B,MAAM,IAAI,GAAG,QAAQ,CAAC,GAAT,EAAb;IACA,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,IAAd;;IACA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAN,CAAd,EAA2B;MACzB,YAAY,CAAC,IAAb,CAAkB,IAAlB;IACD;;IACD,IAAI,CAAC,QAAL,CAAc,OAAd,CAAsB,KAAK,IAAG;MAC5B,IAAI,CAAC,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,IAAf,CAAD,IAAyB,SAAS,CAAC,GAAV,CAAc,KAAK,CAAC,IAApB,CAAzB,IACA,KAAK,CAAC,MAAN,CAAa,KAAb,CAAmB,KAAK,IAAI,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,IAAf,CAA5B,CADJ,EACuD;QACrD,QAAQ,CAAC,IAAT,CAAc,KAAd;MACD;IACF,CALD;EAMD;;EACD,OAAO,YAAP;AACD;AAED,MAAM,gBAAgB,GAAG,CACvB,QADuB,EACb,OADa,EACJ,OADI,EACK,MADL,EACa,eADb,EAC8B,aAD9B,EAEvB,gBAFuB,EAEL,IAFK,EAEC,OAFD,CAAzB;AAIA,MAAM,iBAAiB,GAAG,CACxB,qBADwB,EACD,qBADC,EACsB,qBADtB,EAC6C,OAD7C,CAA1B;AAGA,MAAM,cAAc,GAAG,CACrB,WADqB,EACR,aADQ,EACO,mBADP,EAC4B,qBAD5B,EAErB,iBAFqB,EAEF,mBAFE,EAEmB,iBAFnB,EAEsC,mBAFtC,CAAvB;AAKA,OAAM,SAAU,aAAV,CAAwB,IAAxB,EAAkC;EACtC,OAAO,gBAAgB,CAAC,OAAjB,CAAyB,IAAI,CAAC,EAA9B,KAAqC,CAA5C;AACD;AAED,OAAM,SAAU,cAAV,CAAyB,IAAzB,EAAmC;EACvC,OAAO,iBAAiB,CAAC,OAAlB,CAA0B,IAAI,CAAC,EAA/B,KAAsC,CAA7C;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,IAAtB,EAAgC;EACpC,OAAO,cAAc,CAAC,OAAf,CAAuB,IAAI,CAAC,EAA5B,KAAmC,CAA1C;AACD","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NamedTensorMap} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../data/types';\nimport {parseNodeName} from '../operations/executors/utils';\nimport {Graph, Node} from '../operations/types';\n\nexport interface ExecutionInfo {\n  inputs: NamedTensorMap;\n  outputs: Node[];\n  usedNodes: Set<string>;\n  missingInputs: string[];\n  dynamicNode: Node;\n  syncInputs: string[];\n}\n\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(\n    inputs: NamedTensorMap, outputs: Node[], weightMap: NamedTensorsMap,\n    initNodes?: Node[]): ExecutionInfo {\n  const usedNodes = new Set<string>();\n  const missingInputs: string[] = [];\n  let dynamicNode: Node = null;\n  let syncInputs: string[] = null;\n\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set<string>();\n  const inputNodeNames =\n      Object.keys(inputs).map(name => parseNodeName(name)[0]);\n\n  let initNodeNames: string[] = [];\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n  }\n\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name)\n                         .filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs};\n}\n\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(\n    graph: Graph, weightMap: NamedTensorsMap,\n    executionInfo: ExecutionInfo): Node[] {\n  const {usedNodes, inputs} = executionInfo;\n  const frontier: Node[] = [];\n  const inputNodes = Object.keys(inputs)\n                         .map(name => parseNodeName(name)[0])\n                         .map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes;\n\n  inputNodes.forEach(input => {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(weight => {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n  if (initNodes != null) {\n    initNodes.forEach(node => {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n  const seen = new Set<string>();\n  const orderedNodes: Node[] = [];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    seen.add(node.name);\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n    node.children.forEach(child => {\n      if (!seen.has(child.name) && usedNodes.has(child.name) &&\n          child.inputs.every(input => seen.has(input.name))) {\n        frontier.push(child);\n      }\n    });\n  }\n  return orderedNodes;\n}\n\nconst CONTROL_FLOW_OPS = [\n  'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n  'StatelessWhile', 'if', 'While'\n];\nconst DYNAMIC_SHAPE_OPS = [\n  'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n];\nconst HASH_TABLE_OPS = [\n  'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n  'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'\n];\n\nexport function isControlFlow(node: Node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\n\nexport function isDynamicShape(node: Node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\n\nexport function isHashTable(node: Node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}