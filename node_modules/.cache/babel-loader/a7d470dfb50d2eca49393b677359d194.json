{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core'; // tslint:disable-next-line: no-imports-from-dist\n\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = function (node, tensorMap, context) {\n  let ops = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : tfOps;\n\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        const n = getParamValue('n', node, tensorMap, context);\n        const axis = getParamValue('axis', node, tensorMap, context);\n        let inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [ops.concat(inputs, axis)];\n      }\n\n    case 'Gather':\n      {\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n      }\n\n    case 'GatherV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const batchDims = getParamValue('batchDims', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), axis, batchDims)];\n      }\n\n    case 'Reverse':\n      {\n        const dims = getParamValue('dims', node, tensorMap, context);\n        const axis = [];\n\n        for (let i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            axis.push(i);\n          }\n        }\n\n        const input = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(input, axis)];\n      }\n\n    case 'ReverseV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(input, axis)];\n      }\n\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        const begin = getParamValue('begin', node, tensorMap, context); // tslint:disable-next-line:no-any\n\n        const size = getParamValue('size', node, tensorMap, context);\n        return [ops.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n\n    case 'StridedSlice':\n      {\n        const begin = getParamValue('begin', node, tensorMap, context);\n        const end = getParamValue('end', node, tensorMap, context);\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const beginMask = getParamValue('beginMask', node, tensorMap, context);\n        const endMask = getParamValue('endMask', node, tensorMap, context);\n        const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return [ops.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n\n    case 'Pack':\n      {\n        return tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensors = getParamValue('tensors', node, tensorMap, context); // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n\n          const shape = tensors[0].shape;\n          const squeezedShape = ops.squeeze(tensors[0]).shape;\n          const mapped = tensors.map(tensor => {\n            const sameShape = util.arraysEqual(tensor.shape, shape);\n\n            if (!sameShape && !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n\n            return sameShape ? tensor : ops.reshape(tensor, shape);\n          });\n          return [ops.stack(mapped, axis)];\n        });\n      }\n\n    case 'Unpack':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return ops.unstack(tensor, axis);\n      }\n\n    case 'Tile':\n      {\n        const reps = getParamValue('reps', node, tensorMap, context);\n        return [ops.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n\n    case 'Split':\n    case 'SplitV':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return ops.split(tensor, numOrSizeSplits, axis);\n      }\n\n    case 'ScatterNd':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const shape = getParamValue('shape', node, tensorMap, context);\n        return [ops.scatterND(indices, values, shape)];\n      }\n\n    case 'GatherNd':\n      {\n        const x = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gatherND(x, indices)];\n      }\n\n    case 'SparseToDense':\n      {\n        const indices = getParamValue('sparseIndices', node, tensorMap, context);\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [ops.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];\n      }\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'slice_join';","map":{"version":3,"sources":["../../../../../../../tfjs-converter/src/operations/executors/slice_join_executor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor, Tensor1D, tidy, util} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext, ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n          const n = getParamValue('n', node, tensorMap, context) as number;\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          let inputs =\n              getParamValue('tensors', node, tensorMap, context) as Tensor[];\n          inputs = inputs.slice(0, n);\n          return [ops.concat(inputs, axis)];\n        }\n        case 'Gather': {\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const batchDims =\n              getParamValue('batchDims', node, tensorMap, context) as number;\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(\n              input, ops.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n          const dims =\n              getParamValue('dims', node, tensorMap, context) as boolean[];\n          const axis = [];\n          for (let i = 0; i < dims.length; i++) {\n            if (dims[i]) {\n              axis.push(i);\n            }\n          }\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number[];\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'Slice': {\n          // tslint:disable-next-line:no-any\n          const begin = getParamValue('begin', node, tensorMap, context) as any;\n          // tslint:disable-next-line:no-any\n          const size = getParamValue('size', node, tensorMap, context) as any;\n          return [ops.slice(\n              getParamValue('x', node, tensorMap, context) as Tensor, begin,\n              size)];\n        }\n        case 'StridedSlice': {\n          const begin =\n              getParamValue('begin', node, tensorMap, context) as number[];\n          const end =\n              getParamValue('end', node, tensorMap, context) as number[];\n          const strides =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const beginMask =\n              getParamValue('beginMask', node, tensorMap, context) as number;\n          const endMask =\n              getParamValue('endMask', node, tensorMap, context) as number;\n          const ellipsisMask =\n              getParamValue('ellipsisMask', node, tensorMap, context) as number;\n          const newAxisMask =\n              getParamValue('newAxisMask', node, tensorMap, context) as number;\n          const shrinkAxisMask =\n              getParamValue('shrinkAxisMask', node, tensorMap, context) as\n              number;\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return [ops.stridedSlice(\n              tensor, begin, end, strides, beginMask, endMask, ellipsisMask,\n              newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n          return tidy(() => {\n            const axis =\n                getParamValue('axis', node, tensorMap, context) as number;\n            const tensors =\n                getParamValue('tensors', node, tensorMap, context) as Tensor[];\n            // Reshape the tensors to the first tensor's shape if they don't\n            // match.\n            const shape = tensors[0].shape;\n            const squeezedShape = ops.squeeze(tensors[0]).shape;\n            const mapped = tensors.map(tensor => {\n              const sameShape = util.arraysEqual(tensor.shape, shape);\n              if (!sameShape &&\n                  !util.arraysEqual(\n                      ops.squeeze(tensor).shape, squeezedShape)) {\n                throw new Error('the input tensors shape does not match');\n              }\n              return sameShape ? tensor : ops.reshape(tensor, shape);\n            });\n            return [ops.stack(mapped, axis)];\n          });\n        }\n        case 'Unpack': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return ops.unstack(tensor, axis);\n        }\n        case 'Tile': {\n          const reps =\n              getParamValue('reps', node, tensorMap, context) as number[];\n          return [ops.tile(\n              getParamValue('x', node, tensorMap, context) as Tensor, reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const numOrSizeSplits =\n              getParamValue('numOrSizeSplits', node, tensorMap, context) as\n                  number |\n              number[];\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return ops.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const shape =\n              getParamValue('shape', node, tensorMap, context) as number[];\n          return [ops.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n          const x = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          return [ops.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n          const indices =\n              getParamValue('sparseIndices', node, tensorMap, context) as\n              Tensor;\n          const shape =\n              getParamValue('outputShape', node, tensorMap, context) as\n              number[];\n          const sparseValues =\n              getParamValue('sparseValues', node, tensorMap, context) as Tensor;\n          const defaultValue =\n              getParamValue('defaultValue', node, tensorMap, context) as Scalar;\n          return [ops.sparseToDense(\n              indices, sparseValues, shape,\n              sparseValues.dtype === defaultValue.dtype ?\n                  defaultValue :\n                  ops.cast(defaultValue, sparseValues.dtype))];\n        }\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'slice_join';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}