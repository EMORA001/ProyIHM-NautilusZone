{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, cast, env, expandDims, image, reshape, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\n\nexport class WebcamIterator extends LazyIterator {\n  constructor(webcamVideoElement, webcamConfig) {\n    super();\n    this.webcamVideoElement = webcamVideoElement;\n    this.webcamConfig = webcamConfig;\n    this.isClosed = true;\n    this.resize = false;\n\n    if (this.needToResize()) {\n      this.resize = true;\n      this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n      this.cropBoxInd = tensor1d([0], 'int32');\n\n      if (this.webcamConfig.centerCrop) {\n        // Calculate the box based on resizing shape.\n        const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n        const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 / this.webcamVideoElement.height;\n        const widthCropStart = (1 - widthCroppingRatio) / 2;\n        const heightCropStart = (1 - heightCroppingRatio) / 2;\n        const widthCropEnd = widthCropStart + widthCroppingRatio;\n        const heightCropEnd = heightCroppingRatio + heightCropStart;\n        this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n      } else {\n        this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n  }\n\n  summary() {\n    return `webcam`;\n  } // Construct a WebcamIterator and start it's video stream.\n\n\n  static async create(webcamVideoElement) {\n    let webcamConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!env().get('IS_BROWSER')) {\n      throw new Error('tf.data.webcam is only supported in browser environment.');\n    }\n\n    if (!webcamVideoElement) {\n      // If webcam video element is not provided, create a hidden video element\n      // with provided width and height.\n      webcamVideoElement = document.createElement('video');\n\n      if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n        throw new Error('Please provide webcam video element, or resizeWidth and ' + 'resizeHeight to create a hidden video element.');\n      }\n\n      webcamVideoElement.width = webcamConfig.resizeWidth;\n      webcamVideoElement.height = webcamConfig.resizeHeight;\n    }\n\n    const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig); // Call async function to initialize the video stream.\n\n    await webcamIterator.start();\n    return webcamIterator;\n  } // Async function to start video stream.\n\n\n  async start() {\n    if (this.webcamConfig.facingMode) {\n      util.assert(this.webcamConfig.facingMode === 'user' || this.webcamConfig.facingMode === 'environment', () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` + `Please provide 'user' or 'environment'`);\n    }\n\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          deviceId: this.webcamConfig.deviceId,\n          facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : 'user',\n          width: this.webcamVideoElement.width,\n          height: this.webcamVideoElement.height\n        }\n      });\n    } catch (e) {\n      // Modify the error message but leave the stack trace intact\n      e.message = `Error thrown while initializing video stream: ${e.message}`;\n      throw e;\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain video from webcam.');\n    } // Older browsers may not have srcObject\n\n\n    try {\n      this.webcamVideoElement.srcObject = this.stream;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n    } // Start the webcam video stream\n\n\n    this.webcamVideoElement.play();\n    this.isClosed = false;\n    return new Promise(resolve => {\n      // Add event listener to make sure the webcam has been fully initialized.\n      this.webcamVideoElement.onloadedmetadata = () => {\n        resolve();\n      };\n    });\n  }\n\n  async next() {\n    if (this.isClosed) {\n      return {\n        value: null,\n        done: true\n      };\n    }\n\n    let img;\n\n    try {\n      img = browser.fromPixels(this.webcamVideoElement);\n    } catch (e) {\n      throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n    }\n\n    if (this.resize) {\n      try {\n        return {\n          value: this.cropAndResizeFrame(img),\n          done: false\n        };\n      } catch (e) {\n        throw new Error(`Error thrown cropping the video: ${e.message}`);\n      } finally {\n        img.dispose();\n      }\n    } else {\n      return {\n        value: img,\n        done: false\n      };\n    }\n  }\n\n  needToResize() {\n    // If resizeWidth and resizeHeight are provided, and different from the\n    // width and height of original HTMLVideoElement, then resizing and cropping\n    // is required.\n    if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n      return true;\n    }\n\n    return false;\n  } // Cropping and resizing each frame based on config\n\n\n  cropAndResizeFrame(img) {\n    return tidy(() => {\n      const expandedImage = expandDims(cast(img, 'float32'), 0);\n      let resizedImage;\n      resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear'); // Extract image from batch cropping.\n\n      const shape = resizedImage.shape;\n      return reshape(resizedImage, shape.slice(1));\n    });\n  } // Capture one frame from the video stream, and extract the value from\n  // iterator.next() result.\n\n\n  async capture() {\n    return (await this.next()).value;\n  } // Stop the video stream and pause webcam iterator.\n\n\n  stop() {\n    const tracks = this.stream.getTracks();\n    tracks.forEach(track => track.stop());\n\n    try {\n      this.webcamVideoElement.srcObject = null;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = null;\n    }\n\n    this.isClosed = true;\n  } // Override toArray() function to prevent collecting.\n\n\n  toArray() {\n    throw new Error('Can not convert infinite video stream to array.');\n  }\n\n}","map":{"version":3,"sources":["../../../../../../tfjs-data/src/iterators/webcam_iterator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {browser, cast, env, expandDims, image, reshape, tensor1d, Tensor1D, tensor2d, Tensor2D, Tensor3D, Tensor4D, tidy, util} from '@tensorflow/tfjs-core';\nimport {WebcamConfig} from '../types';\nimport {LazyIterator} from './lazy_iterator';\n\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\nexport class WebcamIterator extends LazyIterator<Tensor3D> {\n  private isClosed = true;\n  private stream: MediaStream;\n  private resize = false;\n  private cropSize: [number, number];\n  private cropBox: Tensor2D;\n  private cropBoxInd: Tensor1D;\n\n  private constructor(\n      protected readonly webcamVideoElement: HTMLVideoElement,\n      protected readonly webcamConfig: WebcamConfig) {\n    super();\n    if (this.needToResize()) {\n      this.resize = true;\n      this.cropSize =\n          [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n      this.cropBoxInd = tensor1d([0], 'int32');\n      if (this.webcamConfig.centerCrop) {\n        // Calculate the box based on resizing shape.\n        const widthCroppingRatio =\n            this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n        const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 /\n            this.webcamVideoElement.height;\n        const widthCropStart = (1 - widthCroppingRatio) / 2;\n        const heightCropStart = (1 - heightCroppingRatio) / 2;\n        const widthCropEnd = widthCropStart + widthCroppingRatio;\n        const heightCropEnd = heightCroppingRatio + heightCropStart;\n        this.cropBox = tensor2d(\n            [heightCropStart, widthCropStart, heightCropEnd, widthCropEnd],\n            [1, 4]);\n      } else {\n        this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n  }\n\n  summary() {\n    return `webcam`;\n  }\n\n  // Construct a WebcamIterator and start it's video stream.\n  static async create(\n      webcamVideoElement?: HTMLVideoElement, webcamConfig: WebcamConfig = {}) {\n    if (!env().get('IS_BROWSER')) {\n      throw new Error(\n          'tf.data.webcam is only supported in browser environment.');\n    }\n\n    if (!webcamVideoElement) {\n      // If webcam video element is not provided, create a hidden video element\n      // with provided width and height.\n      webcamVideoElement = document.createElement('video');\n      if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n        throw new Error(\n            'Please provide webcam video element, or resizeWidth and ' +\n            'resizeHeight to create a hidden video element.');\n      }\n      webcamVideoElement.width = webcamConfig.resizeWidth;\n      webcamVideoElement.height = webcamConfig.resizeHeight;\n    }\n    const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);\n\n    // Call async function to initialize the video stream.\n    await webcamIterator.start();\n\n    return webcamIterator;\n  }\n\n  // Async function to start video stream.\n  async start(): Promise<void> {\n    if (this.webcamConfig.facingMode) {\n      util.assert(\n          (this.webcamConfig.facingMode === 'user') ||\n              (this.webcamConfig.facingMode === 'environment'),\n          () =>\n              `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` +\n              `Please provide 'user' or 'environment'`);\n    }\n\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          deviceId: this.webcamConfig.deviceId,\n          facingMode: this.webcamConfig.facingMode ?\n              this.webcamConfig.facingMode :\n              'user',\n          width: this.webcamVideoElement.width,\n          height: this.webcamVideoElement.height\n        }\n      });\n    } catch (e) {\n      // Modify the error message but leave the stack trace intact\n      e.message = `Error thrown while initializing video stream: ${e.message}`;\n      throw e;\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain video from webcam.');\n    }\n\n    // Older browsers may not have srcObject\n    try {\n      this.webcamVideoElement.srcObject = this.stream;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n    }\n    // Start the webcam video stream\n    this.webcamVideoElement.play();\n\n    this.isClosed = false;\n\n    return new Promise<void>(resolve => {\n      // Add event listener to make sure the webcam has been fully initialized.\n      this.webcamVideoElement.onloadedmetadata = () => {\n        resolve();\n      };\n    });\n  }\n\n  async next(): Promise<IteratorResult<Tensor3D>> {\n    if (this.isClosed) {\n      return {value: null, done: true};\n    }\n\n    let img;\n    try {\n      img = browser.fromPixels(this.webcamVideoElement);\n    } catch (e) {\n      throw new Error(\n          `Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n    }\n    if (this.resize) {\n      try {\n        return {value: this.cropAndResizeFrame(img), done: false};\n      } catch (e) {\n        throw new Error(`Error thrown cropping the video: ${e.message}`);\n      } finally {\n        img.dispose();\n      }\n    } else {\n      return {value: img, done: false};\n    }\n  }\n\n  private needToResize() {\n    // If resizeWidth and resizeHeight are provided, and different from the\n    // width and height of original HTMLVideoElement, then resizing and cropping\n    // is required.\n    if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight &&\n        (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth ||\n         this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n      return true;\n    }\n    return false;\n  }\n\n  // Cropping and resizing each frame based on config\n  cropAndResizeFrame(img: Tensor3D): Tensor3D {\n    return tidy(() => {\n      const expandedImage: Tensor4D = expandDims(cast(img, 'float32'), (0));\n      let resizedImage;\n      resizedImage = image.cropAndResize(\n          expandedImage, this.cropBox, this.cropBoxInd, this.cropSize,\n          'bilinear');\n      // Extract image from batch cropping.\n      const shape = resizedImage.shape;\n      return reshape(resizedImage, shape.slice(1) as [number, number, number]);\n    });\n  }\n\n  // Capture one frame from the video stream, and extract the value from\n  // iterator.next() result.\n  async capture(): Promise<Tensor3D> {\n    return (await this.next()).value;\n  }\n\n  // Stop the video stream and pause webcam iterator.\n  stop(): void {\n    const tracks = this.stream.getTracks();\n\n    tracks.forEach(track => track.stop());\n\n    try {\n      this.webcamVideoElement.srcObject = null;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = null;\n    }\n    this.isClosed = true;\n  }\n\n  // Override toArray() function to prevent collecting.\n  toArray(): Promise<Tensor3D[]> {\n    throw new Error('Can not convert infinite video stream to array.');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}