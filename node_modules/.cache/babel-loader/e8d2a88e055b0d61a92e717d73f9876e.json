{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    segmentIds\n  } = inputs;\n  const {\n    numSegments\n  } = attrs;\n  assertNotComplex(x, 'unsortedSegmentSum');\n  const xRank = x.shape.length;\n  const segmentIdsRank = segmentIds.shape.length;\n  const res = [];\n  const intermediates = []; // Reshape the segment id's so that they can be broadcast with\n  // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n\n  const numIters = xRank - segmentIdsRank;\n  let $segmentIds = segmentIds;\n\n  for (let i = 0; i < numIters; ++i) {\n    const expanded = expandDims({\n      inputs: {\n        input: $segmentIds\n      },\n      backend,\n      attrs: {\n        dim: i + 1\n      }\n    });\n    $segmentIds = expanded;\n    intermediates.push(expanded);\n  }\n\n  for (let i = 0; i < numSegments; ++i) {\n    const scalarValue = util.createScalarValue(i, 'int32');\n    const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n    const mask = equal({\n      inputs: {\n        a: segmentId,\n        b: $segmentIds\n      },\n      backend\n    });\n    const maskCasted = cast({\n      inputs: {\n        x: mask\n      },\n      backend,\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    const mul = multiply({\n      inputs: {\n        a: maskCasted,\n        b: x\n      },\n      backend\n    });\n    const sumTensorInfo = sum({\n      inputs: {\n        x: mul\n      },\n      backend,\n      attrs: {\n        axis: 0,\n        keepDims: false\n      }\n    });\n    res.push(sumTensorInfo);\n    intermediates.push(segmentId);\n    intermediates.push(mask);\n    intermediates.push(maskCasted);\n    intermediates.push(mul);\n    intermediates.push(sumTensorInfo);\n  }\n\n  const result = pack({\n    inputs: res,\n    backend,\n    attrs: {\n      axis: 0\n    }\n  });\n  intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\nexport const unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'cpu',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/UnsortedSegmentSum.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, UnsortedSegmentSum, UnsortedSegmentSumAttrs, UnsortedSegmentSumInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {cast} from './Cast';\nimport {equal} from './Equal';\nimport {expandDims} from './ExpandDims';\nimport {multiply} from './Multiply';\nimport {pack} from './Pack';\nimport {sum} from './Sum';\n\nexport function unsortedSegmentSum(args: {\n  inputs: UnsortedSegmentSumInputs,\n  backend: MathBackendCPU,\n  attrs: UnsortedSegmentSumAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, segmentIds} = inputs;\n  const {numSegments} = attrs;\n\n  assertNotComplex(x, 'unsortedSegmentSum');\n\n  const xRank = x.shape.length;\n  const segmentIdsRank = segmentIds.shape.length;\n  const res = [];\n  const intermediates: TensorInfo[] = [];\n\n  // Reshape the segment id's so that they can be broadcast with\n  // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n  const numIters = xRank - segmentIdsRank;\n  let $segmentIds = segmentIds;\n\n  for (let i = 0; i < numIters; ++i) {\n    const expanded = expandDims(\n        {inputs: {input: $segmentIds}, backend, attrs: {dim: i + 1}});\n    $segmentIds = expanded;\n    intermediates.push(expanded);\n  }\n\n  for (let i = 0; i < numSegments; ++i) {\n    const scalarValue = util.createScalarValue(i as {} as 'int32', 'int32');\n    const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n    const mask =\n        equal({inputs: {a: segmentId, b: $segmentIds}, backend}) as TensorInfo;\n    const maskCasted =\n        cast({inputs: {x: mask}, backend, attrs: {dtype: 'float32'}});\n    const mul =\n        multiply({inputs: {a: maskCasted, b: x}, backend}) as TensorInfo;\n    const sumTensorInfo =\n        sum({inputs: {x: mul}, backend, attrs: {axis: 0, keepDims: false}});\n    res.push(sumTensorInfo);\n    intermediates.push(segmentId);\n    intermediates.push(mask);\n    intermediates.push(maskCasted);\n    intermediates.push(mul);\n    intermediates.push(sumTensorInfo);\n  }\n\n  const result = pack({inputs: res, backend, attrs: {axis: 0}});\n\n  intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return result;\n}\n\nexport const unsortedSegmentSumConfig: KernelConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'cpu',\n  kernelFunc: unsortedSegmentSum as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}