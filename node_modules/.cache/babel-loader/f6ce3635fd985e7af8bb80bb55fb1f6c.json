{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = function (node, tensorMap, context) {\n  let ops = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : tfOps;\n\n  switch (node.op) {\n    case 'Const':\n      {\n        return tensorMap[node.name];\n      }\n\n    case 'PlaceholderWithDefault':\n      const def = getParamValue('default', node, tensorMap, context);\n      return [getTensor(node.name, tensorMap, context) || def];\n\n    case 'Placeholder':\n      return [getTensor(node.name, tensorMap, context)];\n\n    case 'Identity':\n    case 'StopGradient':\n    case 'FakeQuantWithMinMaxVars':\n      {\n        // This op is currently ignored.\n        const data = getParamValue('x', node, tensorMap, context);\n        return [cloneTensor(data)];\n      }\n\n    case 'IdentityN':\n      return getParamValue('x', node, tensorMap, context).map(t => cloneTensor(t));\n\n    case 'Snapshot':\n      const snapshot = getParamValue('x', node, tensorMap, context);\n      return [cloneTensor(snapshot)];\n\n    case 'Shape':\n      return [ops.tensor1d(getParamValue('x', node, tensorMap, context).shape, 'int32')];\n\n    case 'ShapeN':\n      return getParamValue('x', node, tensorMap, context).map(t => ops.tensor1d(t.shape));\n\n    case 'Size':\n      return [ops.scalar(getParamValue('x', node, tensorMap, context).size, 'int32')];\n\n    case 'Rank':\n      return [ops.scalar(getParamValue('x', node, tensorMap, context).rank, 'int32')];\n\n    case 'NoOp':\n      return [ops.scalar(1)];\n\n    case 'Print':\n      const input = getParamValue('x', node, tensorMap, context);\n      const data = getParamValue('data', node, tensorMap, context);\n      const message = getParamValue('message', node, tensorMap, context);\n      const summarize = getParamValue('summarize', node, tensorMap, context);\n      console.warn('The graph has a tf.print() operation,' + 'usually used for debugging, which slows down performance.');\n      console.log(message);\n\n      for (let i = 0; i < data.length; i++) {\n        console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));\n      }\n\n      return [input];\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'graph';","map":{"version":3,"sources":["../../../../../../../tfjs-converter/src/operations/executors/graph_executor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {cloneTensor, getParamValue, getTensor} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext, ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'Const': {\n          return tensorMap[node.name];\n        }\n        case 'PlaceholderWithDefault':\n          const def =\n              getParamValue('default', node, tensorMap, context) as Tensor;\n          return [getTensor(node.name, tensorMap, context) || def];\n        case 'Placeholder':\n          return [getTensor(node.name, tensorMap, context)];\n        case 'Identity':\n        case 'StopGradient':\n        case 'FakeQuantWithMinMaxVars': {  // This op is currently ignored.\n          const data = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [cloneTensor(data)];\n        }\n        case 'IdentityN':\n          return (getParamValue('x', node, tensorMap, context) as Tensor[])\n              .map((t: Tensor) => cloneTensor(t));\n        case 'Snapshot':\n          const snapshot =\n              (getParamValue('x', node, tensorMap, context) as Tensor);\n          return [cloneTensor(snapshot)];\n        case 'Shape':\n          return [ops.tensor1d(\n              (getParamValue('x', node, tensorMap, context) as Tensor).shape,\n              'int32')];\n        case 'ShapeN':\n          return (getParamValue('x', node, tensorMap, context) as Tensor[])\n              .map((t: Tensor) => ops.tensor1d(t.shape));\n        case 'Size':\n          return [ops.scalar(\n              (getParamValue('x', node, tensorMap, context) as Tensor).size,\n              'int32')];\n        case 'Rank':\n          return [ops.scalar(\n              (getParamValue('x', node, tensorMap, context) as Tensor).rank,\n              'int32')];\n        case 'NoOp':\n          return [ops.scalar(1)];\n        case 'Print':\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const data =\n              getParamValue('data', node, tensorMap, context) as Tensor[];\n          const message =\n              getParamValue('message', node, tensorMap, context) as string;\n          const summarize =\n              getParamValue('summarize', node, tensorMap, context) as number;\n          console.warn(\n              'The graph has a tf.print() operation,' +\n              'usually used for debugging, which slows down performance.');\n          console.log(message);\n          for (let i = 0; i < data.length; i++) {\n            console.log(Array.prototype.slice.call(data[i].dataSync())\n                            .slice(0, summarize));\n          }\n          return [input];\n\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'graph';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}