{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n  const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n  const outputColStrides = convInfo.outShape[3];\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    const outputBatchOffset = b * outputBatchStrides;\n    const inputBatchOffset = b * strides[0];\n\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        const xRMin = Math.max(0, xRCorner);\n        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          const xCMin = Math.max(0, xCCorner);\n          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let minMaxValue = initialValue;\n          let avgValue = 0;\n          let count = 0;\n\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const xROffset = inputBatchOffset + xR * strides[1];\n\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const xCOffset = xROffset + xC * strides[2];\n              const pixel = xValues[xCOffset + d];\n\n              if (poolType === 'max' && pixel > minMaxValue) {\n                minMaxValue = pixel;\n              } else if (poolType === 'avg') {\n                avgValue += pixel;\n                count++;\n              }\n            }\n\n            if (isNaN(minMaxValue)) {\n              break;\n            }\n          }\n\n          const outputOffset = outputRowOffset + yC * outputColStrides + d;\n          outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n        }\n      }\n    }\n  }\n\n  return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo) {\n  let flattenPositions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let includeBatchInIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const xBuf = buffer(xShape, dtype, xValues);\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        let xRMin = xRCorner;\n\n        while (xRMin < 0) {\n          xRMin += dilationHeight;\n        } // const xRMin = Math.max(0, xRCorner);\n\n\n        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          let xCMin = xCCorner;\n\n          while (xCMin < 0) {\n            xCMin += dilationWidth;\n          }\n\n          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let maxValue = Number.NEGATIVE_INFINITY;\n          let maxPosition = -1;\n\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const wR = xR - xRCorner;\n\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const wC = xC - xCCorner;\n              const pixel = xBuf.get(b, xR, xC, d);\n\n              if (pixel > maxValue) {\n                maxValue = pixel;\n\n                if (flattenPositions) {\n                  maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                } else {\n                  maxPosition = wR * effectiveFilterWidth + wC;\n                }\n              }\n            }\n          }\n\n          maxPositions.set(maxPosition, b, yR, yC, d);\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}\nexport function pool3d(xValues, xShape, dtype, strides, convInfo, poolType) {\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n  const outputColStrides = convInfo.outShape[4];\n\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    const outputBatchOffset = batch * outputBatchStrides;\n    const inputBatchOffset = batch * strides[0];\n\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n\n        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n\n          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n\n            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n            const outputColOffset = outputRowOffset + yCol * outputColStrides;\n            let minMaxValue = initialValue;\n            let avgValue = 0;\n            let count = 0;\n\n            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n              const xDepthOffset = inputBatchOffset + xDepth * strides[1];\n\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const xRowOffset = xDepthOffset + xRow * strides[2];\n\n                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                  const xColOffset = xRowOffset + xCol * strides[3];\n                  const pixel = xValues[xColOffset + channel];\n\n                  if (poolType === 'max' && pixel > minMaxValue) {\n                    minMaxValue = pixel;\n                  } else if (poolType === 'avg') {\n                    avgValue += pixel;\n                    count++;\n                  }\n\n                  if (isNaN(minMaxValue)) {\n                    break;\n                  }\n                }\n\n                if (isNaN(minMaxValue)) {\n                  break;\n                }\n              }\n\n              if (isNaN(minMaxValue)) {\n                break;\n              }\n            }\n\n            const outputOffset = outputColOffset + channel;\n            outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n          }\n        }\n      }\n    }\n  }\n\n  return output;\n}\nexport function maxPool3dPositions(xBuf, convInfo) {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n\n        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n\n          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n\n            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n            let maxValue = Number.NEGATIVE_INFINITY;\n            let maxPosition = -1;\n\n            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n              const wDepth = xDepth - xDepthCorner;\n\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const wRow = xRow - xRowCorner;\n\n                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                  const wCol = xCol - xColCorner;\n                  const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n\n                  if (pixel >= maxValue) {\n                    maxValue = pixel;\n                    maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;\n                  }\n                }\n              }\n            }\n\n            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n          }\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/utils/pool_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, buffer, DataType, Rank, TensorBuffer, TypedArray} from '@tensorflow/tfjs-core';\n\nexport function pool(\n    xValues: TypedArray, xShape: number[], dtype: DataType, strides: number[],\n    convInfo: backend_util.Conv2DInfo,\n    poolType: 'max'|'avg'): TensorBuffer<Rank, DataType> {\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  const initialValue =\n      (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n                            Number.POSITIVE_INFINITY);\n\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n\n  const outputBatchStrides =\n      convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n  const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n  const outputColStrides = convInfo.outShape[3];\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    const outputBatchOffset = b * outputBatchStrides;\n    const inputBatchOffset = b * strides[0];\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        const xRMin = Math.max(0, xRCorner);\n        const xRMax =\n            Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          const xCMin = Math.max(0, xCCorner);\n          const xCMax =\n              Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let minMaxValue = initialValue;\n          let avgValue = 0;\n          let count = 0;\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const xROffset = inputBatchOffset + xR * strides[1];\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const xCOffset = xROffset + xC * strides[2];\n              const pixel = xValues[xCOffset + d];\n              if ((poolType === 'max' && pixel > minMaxValue)) {\n                minMaxValue = pixel;\n              } else if (poolType === 'avg') {\n                avgValue += pixel;\n                count++;\n              }\n            }\n            if (isNaN(minMaxValue)) {\n              break;\n            }\n          }\n          const outputOffset = outputRowOffset + yC * outputColStrides + d;\n          outputVals[outputOffset] =\n              poolType === 'avg' ? avgValue / count : minMaxValue;\n        }\n      }\n    }\n  }\n  return output;\n}\n\nexport function maxPoolPositions(\n    xValues: TypedArray, xShape: number[], dtype: DataType,\n    convInfo: backend_util.Conv2DInfo, flattenPositions = false,\n    includeBatchInIndex = false): TensorBuffer<Rank, 'int32'> {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  const xBuf = buffer(xShape, dtype, xValues);\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        let xRMin = xRCorner;\n        while (xRMin < 0) {\n          xRMin += dilationHeight;\n        }\n        // const xRMin = Math.max(0, xRCorner);\n        const xRMax =\n            Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          let xCMin = xCCorner;\n          while (xCMin < 0) {\n            xCMin += dilationWidth;\n          }\n          const xCMax =\n              Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let maxValue = Number.NEGATIVE_INFINITY;\n          let maxPosition = -1;\n\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const wR = xR - xRCorner;\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const wC = xC - xCCorner;\n              const pixel = xBuf.get(b, xR, xC, d);\n              if (pixel > maxValue) {\n                maxValue = pixel as number;\n                if (flattenPositions) {\n                  maxPosition = includeBatchInIndex ?\n                      ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) *\n                              convInfo.inChannels +\n                          d :\n                      (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                } else {\n                  maxPosition = wR * effectiveFilterWidth + wC;\n                }\n              }\n            }\n          }\n          maxPositions.set(maxPosition, b, yR, yC, d);\n        }\n      }\n    }\n  }\n  return maxPositions;\n}\n\nexport function pool3d(\n    xValues: TypedArray, xShape: number[], dtype: DataType, strides: number[],\n    convInfo: backend_util.Conv3DInfo,\n    poolType: 'max'|'avg'): TensorBuffer<Rank, DataType> {\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  const initialValue =\n      (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n                            Number.POSITIVE_INFINITY);\n\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n      convInfo.outShape[3] * convInfo.outShape[4];\n  const outputDepthStrides =\n      convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n  const outputColStrides = convInfo.outShape[4];\n\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    const outputBatchOffset = batch * outputBatchStrides;\n    const inputBatchOffset = batch * strides[0];\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n        const xDepthMax =\n            Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        const outputDepthOffset =\n            outputBatchOffset + yDepth * outputDepthStrides;\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n          const xRowMax =\n              Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n            const xColMax =\n                Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n            // Shader code begins\n            const outputColOffset = outputRowOffset + yCol * outputColStrides;\n            let minMaxValue = initialValue;\n            let avgValue = 0;\n            let count = 0;\n            for (let xDepth = xDepthMin; xDepth < xDepthMax;\n                 xDepth += dilationDepth) {\n              const xDepthOffset = inputBatchOffset + xDepth * strides[1];\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const xRowOffset = xDepthOffset + xRow * strides[2];\n                for (let xCol = xColMin; xCol < xColMax;\n                     xCol += dilationWidth) {\n                  const xColOffset = xRowOffset + xCol * strides[3];\n                  const pixel = xValues[xColOffset + channel];\n                  if ((poolType === 'max' && pixel > minMaxValue)) {\n                    minMaxValue = pixel;\n                  } else if (poolType === 'avg') {\n                    avgValue += pixel;\n                    count++;\n                  }\n                  if (isNaN(minMaxValue)) {\n                    break;\n                  }\n                }\n                if (isNaN(minMaxValue)) {\n                  break;\n                }\n              }\n              if (isNaN(minMaxValue)) {\n                break;\n              }\n            }\n            const outputOffset = outputColOffset + channel;\n            outputVals[outputOffset] =\n                poolType === 'avg' ? avgValue / count : minMaxValue;\n          }\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\nexport function maxPool3dPositions(\n    xBuf: TensorBuffer<Rank, DataType>,\n    convInfo: backend_util.Conv3DInfo): TensorBuffer<Rank, DataType> {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n        const xDepthMax =\n            Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n          const xRowMax =\n              Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n            const xColMax =\n                Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n\n            // Shader code begins\n            let maxValue = Number.NEGATIVE_INFINITY;\n            let maxPosition = -1;\n\n            for (let xDepth = xDepthMin; xDepth < xDepthMax;\n                 xDepth += dilationDepth) {\n              const wDepth = xDepth - xDepthCorner;\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const wRow = xRow - xRowCorner;\n                for (let xCol = xColMin; xCol < xColMax;\n                     xCol += dilationWidth) {\n                  const wCol = xCol - xColCorner;\n                  const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                  if (pixel >= maxValue) {\n                    maxValue = pixel as number;\n                    maxPosition =\n                        wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                        wRow * effectiveFilterHeight + wCol;\n                  }\n                }\n              }\n            }\n\n            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n          }\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}