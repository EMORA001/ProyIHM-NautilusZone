{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\n\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n\n\n    x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool( // TODO(cais): Rank check?\n      x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n    }\n\n    return y;\n  });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\n\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // x is NDHWC after preprocessing.\n\n\n    x = preprocessConv3DInput(x, dataFormat);\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n    }\n\n    return y;\n  });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\n\nexport class Pooling1D extends Layer {\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n\n    super(args);\n\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.poolSize)}`);\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(`strides for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.strides)}`);\n      }\n    }\n\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs); // Add dummy last dimension.\n\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast'); // Remove dummy last dimension.\n\n      return tfc.squeeze(output, [2]);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\n\nexport class Pooling2D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` + `it is expected to have a length of 2, but received length ` + `${args.strides.length}.`);\n      }\n\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\n\nexport class Pooling3D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` + `it is expected to have a length of 3, but received length ` + `${args.strides.length}.`);\n      }\n\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\n\nexport class GlobalPooling1D extends Layer {\n  constructor(args) {\n    super(args);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    return [inputShape[0], inputShape[2]];\n  }\n\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\n\nexport class GlobalPooling2D extends Layer {\n  constructor(args) {\n    super(args);\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = inputShape;\n\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n\n  getConfig() {\n    const config = {\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);","map":{"version":3,"sources":["../../../../../../tfjs-layers/src/layers/pooling.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {serialization, Tensor, Tensor3D, Tensor4D, Tensor5D, tidy} from '@tensorflow/tfjs-core';\n\nimport {imageDataFormat} from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport {checkDataFormat, checkPaddingMode, checkPoolMode} from '../common';\nimport {InputSpec} from '../engine/topology';\nimport {Layer, LayerArgs} from '../engine/topology';\nimport {NotImplementedError, ValueError} from '../errors';\nimport {DataFormat, PaddingMode, PoolMode, Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\nimport {convOutputLength} from '../utils/conv_utils';\nimport {assertPositiveInteger} from '../utils/generic_utils';\nimport {getExactlyOneShape, getExactlyOneTensor} from '../utils/types_utils';\n\nimport {preprocessConv2DInput, preprocessConv3DInput} from './convolutional';\n\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(\n    x: Tensor, poolSize: [number, number], strides?: [number, number],\n    padding?: PaddingMode, dataFormat?: DataFormat,\n    poolMode?: PoolMode): Tensor {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n\n    // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n    x = preprocessConv2DInput(x, dataFormat);  // x is NHWC after preprocessing.\n    let y: Tensor;\n    const paddingString = (padding === 'same') ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x as Tensor4D, poolSize, strides, paddingString);\n    } else {  // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool(\n          // TODO(cais): Rank check?\n          x as Tensor3D | Tensor4D, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]);  // NHWC -> NCHW.\n    }\n    return y;\n  });\n}\n\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(\n    x: Tensor5D, poolSize: [number, number, number],\n    strides?: [number, number, number], padding?: PaddingMode,\n    dataFormat?: DataFormat, poolMode?: PoolMode): Tensor {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n\n    // x is NDHWC after preprocessing.\n    x = preprocessConv3DInput(x as Tensor, dataFormat) as Tensor5D;\n    let y: Tensor;\n    const paddingString = (padding === 'same') ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {  // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]);  // NDHWC -> NCDHW.\n    }\n    return y;\n  });\n}\n\nexport declare interface Pooling1DLayerArgs extends LayerArgs {\n  /**\n   * Size of the window to pool over, should be an integer.\n   */\n  poolSize?: number|[number];\n  /**\n   * Period at which to sample the pooled values.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number];\n  /** How to fill in data that's not an integer multiple of poolSize. */\n  padding?: PaddingMode;\n}\n\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport abstract class Pooling1D extends Layer {\n  protected readonly poolSize: [number];\n  protected readonly strides: [number];\n  protected readonly padding: PaddingMode;\n\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args: Pooling1DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n    super(args);\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (\n        Array.isArray(args.poolSize) &&\n        (args.poolSize as number[]).length === 1 &&\n        typeof (args.poolSize as number[])[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(\n          `poolSize for 1D convolutional layer must be a number or an ` +\n          `Array of a single number, but received ` +\n          `${JSON.stringify(args.poolSize)}`);\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (\n          Array.isArray(args.strides) &&\n          (args.strides as number[]).length === 1 &&\n          typeof (args.strides as number[])[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(\n            `strides for 1D convolutional layer must be a number or an ` +\n            `Array of a single number, but received ` +\n            `${JSON.stringify(args.strides)}`);\n      }\n    }\n    assertPositiveInteger(this.strides, 'strides');\n\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({ndim: 3})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(\n        inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor;\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      // Add dummy last dimension.\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(\n          getExactlyOneTensor(inputs), [this.poolSize[0], 1],\n          [this.strides[0], 1], this.padding, 'channelsLast');\n      // Remove dummy last dimension.\n      return tfc.squeeze(output, [2]);\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling1D extends Pooling1D {\n  /** @nocollapse */\n  static className = 'MaxPooling1D';\n  constructor(args: Pooling1DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling1D);\n\nexport class AveragePooling1D extends Pooling1D {\n  /** @nocollapse */\n  static className = 'AveragePooling1D';\n  constructor(args: Pooling1DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling1D);\n\nexport declare interface Pooling2DLayerArgs extends LayerArgs {\n  /**\n   * Factors by which to downscale in each dimension [vertical, horizontal].\n   * Expects an integer or an array of 2 integers.\n   *\n   * For example, `[2, 2]` will halve the input in both spatial dimension.\n   * If only one integer is specified, the same window length\n   * will be used for both dimensions.\n   */\n  poolSize?: number|[number, number];\n\n  /**\n   * The size of the stride in each dimension of the pooling window. Expects\n   * an integer or an array of 2 integers. Integer, tuple of 2 integers, or\n   * None.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number, number];\n\n  /** The padding type to use for the pooling layer. */\n  padding?: PaddingMode;\n  /** The data format to use for the pooling layer. */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport abstract class Pooling2D extends Layer {\n  protected readonly poolSize: [number, number];\n  protected readonly strides: [number, number];\n  protected readonly padding: PaddingMode;\n  protected readonly dataFormat: DataFormat;\n\n  constructor(args: Pooling2DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ?\n        args.poolSize :\n        [args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(\n            `If the strides property of a 2D pooling layer is an Array, ` +\n            `it is expected to have a length of 2, but received length ` +\n            `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows =\n        this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols =\n        this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows =\n        convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols =\n        convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor;\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(\n          getExactlyOneTensor(inputs), this.poolSize, this.strides,\n          this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling2D extends Pooling2D {\n  /** @nocollapse */\n  static className = 'MaxPooling2D';\n  constructor(args: Pooling2DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling2D);\n\nexport class AveragePooling2D extends Pooling2D {\n  /** @nocollapse */\n  static className = 'AveragePooling2D';\n  constructor(args: Pooling2DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling2D);\n\nexport declare interface Pooling3DLayerArgs extends LayerArgs {\n  /**\n   * Factors by which to downscale in each dimension [depth, height, width].\n   * Expects an integer or an array of 3 integers.\n   *\n   * For example, `[2, 2, 2]` will halve the input in three dimensions.\n   * If only one integer is specified, the same window length\n   * will be used for all dimensions.\n   */\n  poolSize?: number|[number, number, number];\n\n  /**\n   * The size of the stride in each dimension of the pooling window. Expects\n   * an integer or an array of 3 integers. Integer, tuple of 3 integers, or\n   * None.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number, number, number];\n\n  /** The padding type to use for the pooling layer. */\n  padding?: PaddingMode;\n  /** The data format to use for the pooling layer. */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport abstract class Pooling3D extends Layer {\n  protected readonly poolSize: [number, number, number];\n  protected readonly strides: [number, number, number];\n  protected readonly padding: PaddingMode;\n  protected readonly dataFormat: DataFormat;\n\n  constructor(args: Pooling3DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ?\n        args.poolSize :\n        [args.poolSize, args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(\n            `If the strides property of a 3D pooling layer is an Array, ` +\n            `it is expected to have a length of 3, but received length ` +\n            `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n\n    this.inputSpec = [new InputSpec({ndim: 5})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths =\n        this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows =\n        this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols =\n        this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(\n        depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows =\n        convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols =\n        convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor;\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(\n          getExactlyOneTensor(inputs), this.poolSize, this.strides,\n          this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling3D extends Pooling3D {\n  /** @nocollapse */\n  static className = 'MaxPooling3D';\n  constructor(args: Pooling3DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(\n        inputs as Tensor5D, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling3D);\n\nexport class AveragePooling3D extends Pooling3D {\n  /** @nocollapse */\n  static className = 'AveragePooling3D';\n  constructor(args: Pooling3DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(\n        inputs as Tensor5D, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling3D);\n\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport abstract class GlobalPooling1D extends Layer {\n  constructor(args: LayerArgs) {\n    super(args);\n    this.inputSpec = [new InputSpec({ndim: 3})];\n  }\n\n  computeOutputShape(inputShape: Shape): Shape {\n    return [inputShape[0], inputShape[2]];\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    throw new NotImplementedError();\n  }\n}\n\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  /** @nocollapse */\n  static className = 'GlobalAveragePooling1D';\n  constructor(args?: LayerArgs) {\n    super(args || {});\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n}\nserialization.registerClass(GlobalAveragePooling1D);\n\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  /** @nocollapse */\n  static className = 'GlobalMaxPooling1D';\n  constructor(args: LayerArgs) {\n    super(args || {});\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n}\nserialization.registerClass(GlobalMaxPooling1D);\n\nexport declare interface GlobalPooling2DLayerArgs extends LayerArgs {\n  /**\n   * One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n   *\n   * The ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\n   * to inputs with shape `[batch, height, width, channels[` while\n   * `CHANNEL_FIRST` corresponds to inputs with shape\n   * `[batch, channels, height, width]`.\n   */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport abstract class GlobalPooling2D extends Layer {\n  protected dataFormat: DataFormat;\n  constructor(args: GlobalPooling2DLayerArgs) {\n    super(args);\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = inputShape as Shape;\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    throw new NotImplementedError();\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config = {dataFormat: this.dataFormat};\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  /** @nocollapse */\n  static className = 'GlobalAveragePooling2D';\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n}\nserialization.registerClass(GlobalAveragePooling2D);\n\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  /** @nocollapse */\n  static className = 'GlobalMaxPooling2D';\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n}\nserialization.registerClass(GlobalMaxPooling2D);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}