{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getPadding, getParamValue } from './utils';\n\nfunction fusedConvAndDepthWiseParams(node, tensorMap, context) {\n  const [extraOp, activationFunc] = getParamValue('fusedOps', node, tensorMap, context);\n  const isBiasAdd = extraOp === 'biasadd';\n  const noBiasAdd = !isBiasAdd;\n  const isPrelu = activationFunc === 'prelu';\n  const isBatchNorm = extraOp === 'fusedbatchnorm';\n  const numArgs = getParamValue('numArgs', node, tensorMap, context);\n\n  if (isBiasAdd) {\n    if (isPrelu && numArgs !== 2) {\n      throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu ' + 'must have two extra arguments: bias and alpha.');\n    }\n\n    if (!isPrelu && isBiasAdd && numArgs !== 1) {\n      throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd must have ' + 'one extra argument: bias.');\n    }\n  }\n\n  if (isBatchNorm) {\n    throw new Error('FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported');\n  }\n\n  const stride = getParamValue('strides', node, tensorMap, context);\n  const pad = getPadding(node, tensorMap, context);\n  const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n  const dilations = getParamValue('dilations', node, tensorMap, context);\n  let [biasArg, preluArg] = getParamValue('args', node, tensorMap, context);\n\n  if (noBiasAdd) {\n    preluArg = biasArg;\n    biasArg = undefined;\n  }\n\n  const leakyreluAlpha = getParamValue('leakyreluAlpha', node, tensorMap, context);\n  return {\n    stride,\n    pad,\n    dataFormat,\n    dilations,\n    biasArg,\n    preluArg,\n    activationFunc,\n    leakyreluAlpha\n  };\n}\n\nexport const executeOp = function (node, tensorMap, context) {\n  let ops = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : tfOps;\n\n  switch (node.op) {\n    case 'Conv1D':\n      {\n        const stride = getParamValue('stride', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        const dilation = getParamValue('dilation', node, tensorMap, context);\n        return [ops.conv1d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];\n      }\n\n    case 'Conv2D':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getPadding(node, tensorMap, context);\n        const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        const dilations = getParamValue('dilations', node, tensorMap, context);\n        return [ops.conv2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];\n      }\n\n    case '_FusedConv2D':\n      {\n        const {\n          stride,\n          pad,\n          dataFormat,\n          dilations,\n          biasArg,\n          preluArg,\n          activationFunc,\n          leakyreluAlpha\n        } = fusedConvAndDepthWiseParams(node, tensorMap, context);\n        return [ops.fused.conv2d({\n          x: getParamValue('x', node, tensorMap, context),\n          filter: getParamValue('filter', node, tensorMap, context),\n          strides: [stride[1], stride[2]],\n          pad: pad,\n          dataFormat: dataFormat,\n          dilations: [dilations[1], dilations[2]],\n          bias: biasArg,\n          activation: activationFunc,\n          preluActivationWeights: preluArg,\n          leakyreluAlpha\n        })];\n      }\n\n    case 'FusedDepthwiseConv2dNative':\n      {\n        const {\n          stride,\n          pad,\n          dataFormat,\n          dilations,\n          biasArg,\n          preluArg,\n          activationFunc,\n          leakyreluAlpha\n        } = fusedConvAndDepthWiseParams(node, tensorMap, context);\n        return [ops.fused.depthwiseConv2d({\n          x: getParamValue('x', node, tensorMap, context),\n          filter: getParamValue('filter', node, tensorMap, context),\n          strides: [stride[1], stride[2]],\n          pad: pad,\n          dataFormat: dataFormat,\n          dilations: [dilations[1], dilations[2]],\n          bias: biasArg,\n          activation: activationFunc,\n          preluActivationWeights: preluArg,\n          leakyreluAlpha\n        })];\n      }\n\n    case 'Conv2DBackpropInput':\n    case 'Conv2dTranspose':\n      {\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getPadding(node, tensorMap, context);\n        return [ops.conv2dTranspose(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];\n      }\n\n    case 'DepthwiseConv2dNative':\n    case 'DepthwiseConv2d':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getPadding(node, tensorMap, context);\n        const dilations = getParamValue('dilations', node, tensorMap, context);\n        const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        return [ops.depthwiseConv2d(getParamValue('input', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];\n      }\n\n    case 'Conv3D':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        const dilations = getParamValue('dilations', node, tensorMap, context);\n        return [ops.conv3d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2], stride[3]], pad, dataFormat, [dilations[1], dilations[2], dilations[3]])];\n      }\n\n    case 'AvgPool':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [ops.avgPool(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n      }\n\n    case 'MaxPool':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [ops.maxPool(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n      }\n\n    case 'MaxPoolWithArgmax':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        const includeBatchInIndex = getParamValue('includeBatchInIndex', node, tensorMap, context);\n        const {\n          result,\n          indexes\n        } = ops.maxPoolWithArgmax(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad, includeBatchInIndex);\n        return [result, indexes];\n      }\n\n    case 'AvgPool3D':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [ops.avgPool3d(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad)];\n      }\n\n    case 'MaxPool3D':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [ops.maxPool3d(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad)];\n      }\n\n    case 'Dilation2D':\n      {\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const dilations = getParamValue('dilations', node, tensorMap, context); // strides: [1, stride_height, stride_width, 1].\n\n        const strideHeight = strides[1];\n        const strideWidth = strides[2]; // dilations: [1, dilation_height, dilation_width, 1].\n\n        const dilationHeight = dilations[1];\n        const dilationWidth = dilations[2];\n        return [ops.dilation2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [strideHeight, strideWidth], pad, [dilationHeight, dilationWidth], 'NHWC'\n        /* dataFormat */\n        )];\n      }\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'convolution';","map":{"version":3,"sources":["../../../../../../../tfjs-converter/src/operations/executors/convolution_executor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Rank, Tensor, Tensor3D, Tensor4D, Tensor5D} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getPadding, getParamValue} from './utils';\n\nfunction fusedConvAndDepthWiseParams(\n    node: Node, tensorMap: NamedTensorsMap, context: ExecutionContext) {\n  const [extraOp, activationFunc] =\n      (getParamValue('fusedOps', node, tensorMap, context) as string[]);\n\n  const isBiasAdd = extraOp === 'biasadd';\n  const noBiasAdd = !isBiasAdd;\n  const isPrelu = activationFunc === 'prelu';\n  const isBatchNorm = extraOp === 'fusedbatchnorm';\n\n  const numArgs =\n      (getParamValue('numArgs', node, tensorMap, context) as number);\n  if (isBiasAdd) {\n    if (isPrelu && numArgs !== 2) {\n      throw new Error(\n          'FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu ' +\n          'must have two extra arguments: bias and alpha.');\n    }\n    if (!isPrelu && isBiasAdd && numArgs !== 1) {\n      throw new Error(\n          'FusedConv2d and DepthwiseConv2d with BiasAdd must have ' +\n          'one extra argument: bias.');\n    }\n  }\n  if (isBatchNorm) {\n    throw new Error(\n        'FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported');\n  }\n  const stride = getParamValue('strides', node, tensorMap, context) as number[];\n  const pad = getPadding(node, tensorMap, context);\n  const dataFormat =\n      (getParamValue('dataFormat', node, tensorMap, context) as string)\n          .toUpperCase();\n  const dilations =\n      getParamValue('dilations', node, tensorMap, context) as number[];\n  let [biasArg, preluArg] =\n      getParamValue('args', node, tensorMap, context) as Tensor[];\n  if (noBiasAdd) {\n    preluArg = biasArg;\n    biasArg = undefined;\n  }\n  const leakyreluAlpha =\n      getParamValue('leakyreluAlpha', node, tensorMap, context) as number;\n\n  return {\n    stride,\n    pad,\n    dataFormat,\n    dilations,\n    biasArg,\n    preluArg,\n    activationFunc,\n    leakyreluAlpha\n  };\n}\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext, ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'Conv1D': {\n          const stride =\n              getParamValue('stride', node, tensorMap, context) as number;\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const dataFormat =\n              (getParamValue('dataFormat', node, tensorMap, context) as string)\n                  .toUpperCase();\n          const dilation =\n              getParamValue('dilation', node, tensorMap, context) as number;\n          return [ops.conv1d(\n              getParamValue('x', node, tensorMap, context) as Tensor3D,\n              getParamValue('filter', node, tensorMap, context) as Tensor3D,\n              stride, pad as 'valid' | 'same', dataFormat as 'NWC' | 'NCW',\n              dilation)];\n        }\n        case 'Conv2D': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getPadding(node, tensorMap, context);\n          const dataFormat =\n              (getParamValue('dataFormat', node, tensorMap, context) as string)\n                  .toUpperCase();\n          const dilations =\n              getParamValue('dilations', node, tensorMap, context) as number[];\n          return [ops.conv2d(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('filter', node, tensorMap, context) as Tensor4D,\n              [stride[1], stride[2]], pad as 'valid' | 'same',\n              dataFormat as 'NHWC' | 'NCHW', [dilations[1], dilations[2]])];\n        }\n        case '_FusedConv2D': {\n          const {\n            stride,\n            pad,\n            dataFormat,\n            dilations,\n            biasArg,\n            preluArg,\n            activationFunc,\n            leakyreluAlpha\n          } = fusedConvAndDepthWiseParams(node, tensorMap, context);\n\n          return [ops.fused.conv2d({\n            x: getParamValue('x', node, tensorMap, context) as Tensor3D |\n                Tensor4D,\n            filter: getParamValue('filter', node, tensorMap, context) as\n                Tensor4D,\n            strides: [stride[1], stride[2]],\n            pad: pad as 'valid' | 'same',\n            dataFormat: dataFormat as 'NHWC' | 'NCHW',\n            dilations: [dilations[1], dilations[2]],\n            bias: biasArg,\n            activation: activationFunc as tfOps.fused.Activation,\n            preluActivationWeights: preluArg,\n            leakyreluAlpha\n          })];\n        }\n\n        case 'FusedDepthwiseConv2dNative': {\n          const {\n            stride,\n            pad,\n            dataFormat,\n            dilations,\n            biasArg,\n            preluArg,\n            activationFunc,\n            leakyreluAlpha,\n          } = fusedConvAndDepthWiseParams(node, tensorMap, context);\n\n          return [ops.fused.depthwiseConv2d({\n            x: getParamValue('x', node, tensorMap, context) as Tensor3D |\n                Tensor4D,\n            filter: getParamValue('filter', node, tensorMap, context) as\n                Tensor4D,\n            strides: [stride[1], stride[2]],\n            pad: pad as 'valid' | 'same',\n            dataFormat: dataFormat as 'NHWC' | 'NCHW',\n            dilations: [dilations[1], dilations[2]],\n            bias: biasArg,\n            activation: activationFunc as tfOps.fused.Activation,\n            preluActivationWeights: preluArg,\n            leakyreluAlpha\n          })];\n        }\n        case 'Conv2DBackpropInput':\n        case 'Conv2dTranspose': {\n          const shape = getParamValue(\n                            'outputShape', node, tensorMap,\n                            context) as [number, number, number] |\n              [number, number, number, number];\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getPadding(node, tensorMap, context);\n          return [ops.conv2dTranspose(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('filter', node, tensorMap, context) as Tensor4D,\n              shape, [stride[1], stride[2]], pad as 'valid' | 'same')];\n        }\n        case 'DepthwiseConv2dNative':\n        case 'DepthwiseConv2d': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getPadding(node, tensorMap, context);\n          const dilations =\n              getParamValue('dilations', node, tensorMap, context) as number[];\n          const dataFormat =\n              (getParamValue('dataFormat', node, tensorMap, context) as string)\n                  .toUpperCase();\n\n          return [ops.depthwiseConv2d(\n              getParamValue('input', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('filter', node, tensorMap, context) as Tensor4D,\n              [stride[1], stride[2]], pad as 'valid' | 'same',\n              dataFormat as 'NHWC' | 'NCHW', [dilations[1], dilations[2]])];\n        }\n        case 'Conv3D': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const dataFormat =\n              (getParamValue('dataFormat', node, tensorMap, context) as string)\n                  .toUpperCase();\n          const dilations =\n              getParamValue('dilations', node, tensorMap, context) as number[];\n          return [ops.conv3d(\n              getParamValue('x', node, tensorMap, context) as Tensor4D |\n                  Tensor<Rank.R5>,\n              getParamValue('filter', node, tensorMap, context) as\n                  Tensor<Rank.R5>,\n              [stride[1], stride[2], stride[3]], pad as 'valid' | 'same',\n              dataFormat as 'NDHWC' | 'NCDHW',\n              [dilations[1], dilations[2], dilations[3]])];\n        }\n        case 'AvgPool': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n\n          return [ops.avgPool(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              [kernelSize[1], kernelSize[2]], [stride[1], stride[2]],\n              pad as 'valid' | 'same')];\n        }\n        case 'MaxPool': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n\n          return [ops.maxPool(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              [kernelSize[1], kernelSize[2]], [stride[1], stride[2]],\n              pad as 'valid' | 'same')];\n        }\n        case 'MaxPoolWithArgmax': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n          const includeBatchInIndex =\n              getParamValue('includeBatchInIndex', node, tensorMap, context) as\n              boolean;\n          const {result, indexes} = ops.maxPoolWithArgmax(\n              getParamValue('x', node, tensorMap, context) as Tensor4D,\n              [kernelSize[1], kernelSize[2]], [stride[1], stride[2]],\n              pad as 'valid' | 'same', includeBatchInIndex);\n          return [result, indexes];\n        }\n        case 'AvgPool3D': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n\n          return [ops.avgPool3d(\n              getParamValue('x', node, tensorMap, context) as Tensor5D,\n              [kernelSize[1], kernelSize[2], kernelSize[3]],\n              [stride[1], stride[2], stride[3]], pad as 'valid' | 'same')];\n        }\n\n        case 'MaxPool3D': {\n          const stride =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const kernelSize =\n              getParamValue('kernelSize', node, tensorMap, context) as number[];\n\n          return [ops.maxPool3d(\n              getParamValue('x', node, tensorMap, context) as Tensor5D,\n              [kernelSize[1], kernelSize[2], kernelSize[3]],\n              [stride[1], stride[2], stride[3]], pad as 'valid' | 'same')];\n        }\n\n        case 'Dilation2D': {\n          const strides =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const pad = getParamValue('pad', node, tensorMap, context);\n          const dilations =\n              getParamValue('dilations', node, tensorMap, context) as number[];\n\n          // strides: [1, stride_height, stride_width, 1].\n          const strideHeight = strides[1];\n          const strideWidth = strides[2];\n\n          // dilations: [1, dilation_height, dilation_width, 1].\n          const dilationHeight = dilations[1];\n          const dilationWidth = dilations[2];\n\n          return [ops.dilation2d(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('filter', node, tensorMap, context) as Tensor3D,\n              [strideHeight, strideWidth], pad as 'valid' | 'same',\n              [dilationHeight, dilationWidth], 'NHWC' /* dataFormat */)];\n        }\n\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'convolution';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}