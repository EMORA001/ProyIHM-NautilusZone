{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Padding Layers.\n */\n// Porting Note: In Python Keras, the padding layers are in convolutional.py,\n//   but we decided to put them in a separate file (padding.ts) for clarity.\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { ValueError } from '../errors';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\n/**\n * Pads the middle dimension of a 3D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of 2 integers, how many zeros to add at the start and\n *   end of the middle dimension (i.e., dimension 1).\n * @return A padded 3D `tf.Tensor`.\n */\n\nexport function temporalPadding(x, padding) {\n  return tidy(() => {\n    if (x.rank !== 3) {\n      throw new ValueError(`temporalPadding expects input tensor to be 3-D, but received a ` + `${x.rank}-D tensor.`);\n    }\n\n    if (padding == null) {\n      padding = [1, 1];\n    }\n\n    if (padding.length !== 2) {\n      throw new ValueError(`temporalPadding expects input padding pattern to be a length-2 ` + `array, but received a length-${padding.length} array.`);\n    }\n\n    const pattern = [[0, 0], padding, [0, 0]];\n    return tfc.pad(x, pattern);\n  });\n}\n/**\n * Pads the 2nd and 3rd dimensions of a 4D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of two `Array`s, each of which is an `Array` of two\n *   integers. The amount of padding at the beginning and end of the 2nd and 3rd\n *   dimensions, respectively.\n * @param dataFormat 'channelsLast' (default) or 'channelsFirst'.\n * @return Padded 4D `tf.Tensor`.\n */\n\nexport function spatial2dPadding(x, padding, dataFormat) {\n  return tidy(() => {\n    if (x.rank !== 4) {\n      throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ` + `${x.rank}-D tensor.`);\n    }\n\n    if (padding == null) {\n      padding = [[1, 1], [1, 1]];\n    }\n\n    if (padding.length !== 2 || padding[0].length !== 2 || padding[1].length !== 2) {\n      throw new ValueError('spatial2dPadding expects `padding` to be an Array of two Arrays, ' + 'each of which is an Array of two integers.');\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {\n      throw new ValueError(`Unknown data format: ${dataFormat}. ` + `Supported data formats are 'channelsLast' and 'channelsFirst.`);\n    }\n\n    let pattern;\n\n    if (dataFormat === 'channelsFirst') {\n      pattern = [[0, 0], [0, 0], padding[0], padding[1]];\n    } else {\n      pattern = [[0, 0], padding[0], padding[1], [0, 0]];\n    }\n\n    return tfc.pad(x, pattern);\n  });\n}\nexport class ZeroPadding2D extends Layer {\n  constructor(args) {\n    if (args == null) {\n      args = {};\n    }\n\n    super(args);\n    this.dataFormat = args.dataFormat == null ? imageDataFormat() : args.dataFormat; // TODO(cais): Maybe refactor the following logic surrounding `padding`\n    //   into a helper method.\n\n    if (args.padding == null) {\n      this.padding = [[1, 1], [1, 1]];\n    } else if (typeof args.padding === 'number') {\n      this.padding = [[args.padding, args.padding], [args.padding, args.padding]];\n    } else {\n      args.padding = args.padding;\n\n      if (args.padding.length !== 2) {\n        throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but ` + `received a length-${args.padding.length} array.`);\n      }\n\n      let heightPadding;\n      let widthPadding;\n\n      if (typeof args.padding[0] === 'number') {\n        heightPadding = [args.padding[0], args.padding[0]];\n        widthPadding = [args.padding[1], args.padding[1]];\n      } else {\n        args.padding = args.padding;\n\n        if (args.padding[0].length !== 2) {\n          throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, ` + `but received a length-${args.padding[0].length} array.`);\n        }\n\n        heightPadding = args.padding[0];\n\n        if (args.padding[1].length !== 2) {\n          throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, ` + `but received a length-${args.padding[1].length} array.`);\n        }\n\n        widthPadding = args.padding[1];\n      }\n\n      this.padding = [heightPadding, widthPadding];\n    }\n\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows;\n    let cols;\n\n    if (this.dataFormat === 'channelsFirst') {\n      if (inputShape[2] != null && inputShape[2] >= 0) {\n        rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];\n      } else {\n        rows = null;\n      }\n\n      if (inputShape[3] != null && inputShape[3] >= 0) {\n        cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];\n      } else {\n        cols = null;\n      }\n\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      if (inputShape[1] != null && inputShape[1] >= 0) {\n        rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];\n      } else {\n        rows = null;\n      }\n\n      if (inputShape[2] != null && inputShape[2] >= 0) {\n        cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];\n      } else {\n        cols = null;\n      }\n\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => spatial2dPadding(getExactlyOneTensor(inputs), this.padding, this.dataFormat));\n  }\n\n  getConfig() {\n    const config = {\n      padding: this.padding,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\n/** @nocollapse */\n\nZeroPadding2D.className = 'ZeroPadding2D';\nserialization.registerClass(ZeroPadding2D);","map":{"version":3,"sources":["../../../../../../tfjs-layers/src/layers/padding.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Padding Layers.\n */\n\n// Porting Note: In Python Keras, the padding layers are in convolutional.py,\n//   but we decided to put them in a separate file (padding.ts) for clarity.\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {serialization, Tensor, tidy} from '@tensorflow/tfjs-core';\n\nimport {imageDataFormat} from '../backend/common';\nimport {InputSpec, Layer, LayerArgs} from '../engine/topology';\nimport {ValueError} from '../errors';\nimport {DataFormat, Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\nimport {getExactlyOneShape, getExactlyOneTensor} from '../utils/types_utils';\n\n/**\n * Pads the middle dimension of a 3D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of 2 integers, how many zeros to add at the start and\n *   end of the middle dimension (i.e., dimension 1).\n * @return A padded 3D `tf.Tensor`.\n */\nexport function temporalPadding(x: Tensor, padding?: [number, number]): Tensor {\n  return tidy(() => {\n    if (x.rank !== 3) {\n      throw new ValueError(\n          `temporalPadding expects input tensor to be 3-D, but received a ` +\n          `${x.rank}-D tensor.`);\n    }\n\n    if (padding == null) {\n      padding = [1, 1];\n    }\n    if (padding.length !== 2) {\n      throw new ValueError(\n          `temporalPadding expects input padding pattern to be a length-2 ` +\n          `array, but received a length-${padding.length} array.`);\n    }\n\n    const pattern: Array<[number, number]> = [[0, 0], padding, [0, 0]];\n    return tfc.pad(x, pattern);\n  });\n}\n\n/**\n * Pads the 2nd and 3rd dimensions of a 4D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of two `Array`s, each of which is an `Array` of two\n *   integers. The amount of padding at the beginning and end of the 2nd and 3rd\n *   dimensions, respectively.\n * @param dataFormat 'channelsLast' (default) or 'channelsFirst'.\n * @return Padded 4D `tf.Tensor`.\n */\nexport function spatial2dPadding(\n    x: Tensor, padding?: [[number, number], [number, number]],\n    dataFormat?: DataFormat): Tensor {\n  return tidy(() => {\n    if (x.rank !== 4) {\n      throw new ValueError(\n          `temporalPadding expects input tensor to be 4-D, but received a ` +\n          `${x.rank}-D tensor.`);\n    }\n\n    if (padding == null) {\n      padding = [[1, 1], [1, 1]];\n    }\n    if (padding.length !== 2 || padding[0].length !== 2 ||\n        padding[1].length !== 2) {\n      throw new ValueError(\n          'spatial2dPadding expects `padding` to be an Array of two Arrays, ' +\n          'each of which is an Array of two integers.');\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {\n      throw new ValueError(\n          `Unknown data format: ${dataFormat}. ` +\n          `Supported data formats are 'channelsLast' and 'channelsFirst.`);\n    }\n\n    let pattern: Array<[number, number]>;\n    if (dataFormat === 'channelsFirst') {\n      pattern = [[0, 0], [0, 0], padding[0], padding[1]];\n    } else {\n      pattern = [[0, 0], padding[0], padding[1], [0, 0]];\n    }\n\n    return tfc.pad(x, pattern);\n  });\n}\n\nexport declare interface ZeroPadding2DLayerArgs extends LayerArgs {\n  /**\n   * Integer, or `Array` of 2 integers, or `Array` of 2 `Array`s, each of\n   * which is an `Array` of 2 integers.\n   * - If integer, the same symmetric padding is applied to width and height.\n   * - If Array` of 2 integers, interpreted as two different symmetric values\n   *   for height and width:\n   *   `[symmetricHeightPad, symmetricWidthPad]`.\n   * - If `Array` of 2 `Array`s, interpreted as:\n   *   `[[topPad, bottomPad], [leftPad, rightPad]]`.\n   */\n  padding?: number|[number, number]|[[number, number], [number, number]];\n\n  /**\n   * One of `'channelsLast'` (default) and `'channelsFirst'`.\n   *\n   * The ordering of the dimensions in the inputs.\n   * `channelsLast` corresponds to inputs with shape\n   * `[batch, height, width, channels]` while `channelsFirst`\n   * corresponds to inputs with shape\n   * `[batch, channels, height, width]`.\n   */\n  dataFormat?: DataFormat;\n}\n\nexport class ZeroPadding2D extends Layer {\n  /** @nocollapse */\n  static className = 'ZeroPadding2D';\n  readonly dataFormat: DataFormat;\n  readonly padding: [[number, number], [number, number]];\n\n  constructor(args?: ZeroPadding2DLayerArgs) {\n    if (args == null) {\n      args = {};\n    }\n    super(args);\n\n    this.dataFormat =\n        args.dataFormat == null ? imageDataFormat() : args.dataFormat;\n    // TODO(cais): Maybe refactor the following logic surrounding `padding`\n    //   into a helper method.\n    if (args.padding == null) {\n      this.padding = [[1, 1], [1, 1]];\n    } else if (typeof args.padding === 'number') {\n      this.padding =\n          [[args.padding, args.padding], [args.padding, args.padding]];\n    } else {\n      args.padding = args.padding;\n      if (args.padding.length !== 2) {\n        throw new ValueError(\n            `ZeroPadding2D expects padding to be a length-2 array, but ` +\n            `received a length-${args.padding.length} array.`);\n      }\n\n      let heightPadding: [number, number];\n      let widthPadding: [number, number];\n      if (typeof args.padding[0] === 'number') {\n        heightPadding = [args.padding[0], args.padding[0]];\n        widthPadding = [args.padding[1] as number, args.padding[1] as number];\n      } else {\n        args.padding = args.padding as [[number, number], [number, number]];\n\n        if (args.padding[0].length !== 2) {\n          throw new ValueError(\n              `ZeroPadding2D expects height padding to be a length-2 array, ` +\n              `but received a length-${args.padding[0].length} array.`);\n        }\n        heightPadding = args.padding[0] as [number, number];\n\n        if (args.padding[1].length !== 2) {\n          throw new ValueError(\n              `ZeroPadding2D expects width padding to be a length-2 array, ` +\n              `but received a length-${args.padding[1].length} array.`);\n        }\n        widthPadding = args.padding[1] as [number, number];\n      }\n      this.padding = [heightPadding, widthPadding];\n    }\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n\n    let rows: number;\n    let cols: number;\n    if (this.dataFormat === 'channelsFirst') {\n      if (inputShape[2] != null && inputShape[2] >= 0) {\n        rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];\n      } else {\n        rows = null;\n      }\n      if (inputShape[3] != null && inputShape[3] >= 0) {\n        cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];\n      } else {\n        cols = null;\n      }\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      if (inputShape[1] != null && inputShape[1] >= 0) {\n        rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];\n      } else {\n        rows = null;\n      }\n      if (inputShape[2] != null && inputShape[2] >= 0) {\n        cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];\n      } else {\n        cols = null;\n      }\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(\n        () => spatial2dPadding(\n            getExactlyOneTensor(inputs), this.padding, this.dataFormat));\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      padding: this.padding,\n      dataFormat: this.dataFormat,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nserialization.registerClass(ZeroPadding2D);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}